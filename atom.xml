<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wayne&#39;s blog</title>
  
  <subtitle>一个有情调的程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-03T04:47:41.398Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>侯骅十</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis应用实践——scan指令</title>
    <link href="http://yoursite.com/posts/17414/"/>
    <id>http://yoursite.com/posts/17414/</id>
    <published>2019-10-03T04:43:44.000Z</published>
    <updated>2019-10-03T04:47:41.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis应用实践——scan指令"><a href="#Redis应用实践——scan指令" class="headerlink" title="Redis应用实践——scan指令"></a>Redis应用实践——scan指令</h1><p>从某种程度上来说，scan是来取代keys指令的。传统的keys指令不仅没有limit这类的参数，而且是通过遍历查找，复杂度是O(n)。</p><h2 id="scan的基本用法"><a href="#scan的基本用法" class="headerlink" title="scan的基本用法"></a>scan的基本用法</h2><ul><li><code>scan 0 match key99** count 1000</code></li></ul><p>上面的 0 为cursor游标参数，这条指令执行完，会返回一个游标， 返回的游标不为0则代表还没有遍历完成。</p><p>上面的 1000 为limit值，但是这个值并不是指定了返回结果集的数量，而是服务器本次遍历的字典槽位数量（约等于）。所以你会发现，设置了1000的limit，返回的结果可能只有10条左右。</p><h2 id="scan的遍历顺序"><a href="#scan的遍历顺序" class="headerlink" title="scan的遍历顺序"></a>scan的遍历顺序</h2><p>在你使用scan指令做了实验后，你可能发现，返回的游标并不是一次比一次大的。因为scan指令确实使用的不是从0开始顺序遍历的方法。</p><p>这是因为redis考虑到了字典扩容或者缩容的情况，所以使用了高位加法的方法来决定遍历的顺序。（原理代论证，这里不是很清楚）这样扩容后，可以继续从当前的槽往后遍历，之前的全部是已遍历过的，之后的都没有遍历过。</p><h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>在扩容的过程中，如果key比较大，那么对所有元素进行rehash将会消耗比较长的时间，而redis又是单线程的，所以采用了渐进式的策略，也就是同时维护两个数组，在查找元素时如果一个找不到就要区另一个里面找。scan命令也需要同时扫描新旧的槽位。</p><h2 id="大key扫描"><a href="#大key扫描" class="headerlink" title="大key扫描"></a>大key扫描</h2><p>如果一个key过大，在迁移时就会造成卡顿，而且在需要扩容时，也会一次性申请两倍大小的空间。</p><p>所以在业务开发中，尽量避免大key的产生，如果监控发现redis的内存大起大落，那就很可能时大key导致的问题。</p><p>redis-cli给我们提供了扫描大key的功能<code>redis-cli -h 127.0.0.1 -p 7001 --bigkeys</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis应用实践——scan指令&quot;&gt;&lt;a href=&quot;#Redis应用实践——scan指令&quot; class=&quot;headerlink&quot; title=&quot;Redis应用实践——scan指令&quot;&gt;&lt;/a&gt;Redis应用实践——scan指令&lt;/h1&gt;&lt;p&gt;从某种程度上来说，s
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis应用实践——GeoHash</title>
    <link href="http://yoursite.com/posts/19085/"/>
    <id>http://yoursite.com/posts/19085/</id>
    <published>2019-10-03T04:43:40.000Z</published>
    <updated>2019-10-03T04:47:22.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis应用实践——GeoHash"><a href="#Redis应用实践——GeoHash" class="headerlink" title="Redis应用实践——GeoHash"></a>Redis应用实践——GeoHash</h1><p>业界比较通用的距离排序算法，是GeoHash，Redis也使用了GeoHash算法。</p><p>可以用来实现附近的人，附近的单车，附近的司机等等功能。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>主要思路是将二维的坐标映射为一维的整数，比较基础容易理解的如二刀法。把正方形切一刀，然后再二分切一刀，再切 越来越小，然后每个切出来的正方形都用00,01,02这样的数字来表示，切的越多，数字越长，位置也更精确。</p><p>Geo算法会继续对这个整数做一次base32编码。在Redis中，将这个编码作为value放入zset中，score使用 经纬度编成的52位编码，可以用来排序距离。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li><p><code>geoadd``geodist``getpos</code></p></li><li><p><code>gethash</code></p></li><li><p><code>georadiusbymember</code>获取一定距离范围内的元素</p></li><li><p><code>georadius</code>提供坐标查询一定距离范围内的元素</p></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>数据量很大之后，Geo的占用空间将会很大，如果单个key的数据过大，在迁移时会产生较大的性能影响。所以建议Geo使用单独的Redis实例部署。如果数据量更大，需要对Geo进行拆分，如按省市区来拆分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis应用实践——GeoHash&quot;&gt;&lt;a href=&quot;#Redis应用实践——GeoHash&quot; class=&quot;headerlink&quot; title=&quot;Redis应用实践——GeoHash&quot;&gt;&lt;/a&gt;Redis应用实践——GeoHash&lt;/h1&gt;&lt;p&gt;业界比较通用
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis应用实践——简单限流与漏斗限流</title>
    <link href="http://yoursite.com/posts/50064/"/>
    <id>http://yoursite.com/posts/50064/</id>
    <published>2019-10-03T04:43:35.000Z</published>
    <updated>2019-10-03T04:46:24.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis应用实践——简单限流与漏斗限流"><a href="#Redis应用实践——简单限流与漏斗限流" class="headerlink" title="Redis应用实践——简单限流与漏斗限流"></a>Redis应用实践——简单限流与漏斗限流</h1><h2 id="简单限流"><a href="#简单限流" class="headerlink" title="简单限流"></a>简单限流</h2><p>实现原理就是使用zset结构，加上滑动窗口的思路来实现简单的时间窗口滑动。</p><ul><li><p>zset的score存储时间戳。</p></li><li><p>代码中使用zremrangebyscore把时间窗口之前的访问记录都砍掉。</p></li><li><p>给每个新的记录设置一个过期时间（时间窗口的长度 可以再+1s）</p></li></ul><h2 id="漏斗限流"><a href="#漏斗限流" class="headerlink" title="漏斗限流"></a>漏斗限流</h2><p>如果自己实现一个漏斗算法需要如下</p><ul><li><p>定义容量、漏水速率、漏水时间、剩余容量等</p></li><li><p>每次请求的时候用当前时间乘漏斗速率，看看需要的空间能不能满足需要的空间。</p></li></ul><h2 id="redis中提供的漏斗限流"><a href="#redis中提供的漏斗限流" class="headerlink" title="redis中提供的漏斗限流"></a>redis中提供的漏斗限流</h2><p>Redis4.0中开始提供了一个限流模块：REdis-Cell，该模块提供了限流算法，并且提供了原子命令。</p><p>该模块只有一条指令<code>cl.throttle</code></p><p>使用方法<code>cl.throttle key 15 40 60 1</code></p><blockquote><p>15 ：漏斗容量</p><p>40 60: 40 operations /60 seconds 漏斗速率</p><p>1：可选参数 quota</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis应用实践——简单限流与漏斗限流&quot;&gt;&lt;a href=&quot;#Redis应用实践——简单限流与漏斗限流&quot; class=&quot;headerlink&quot; title=&quot;Redis应用实践——简单限流与漏斗限流&quot;&gt;&lt;/a&gt;Redis应用实践——简单限流与漏斗限流&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis应用实践——布隆过滤器</title>
    <link href="http://yoursite.com/posts/3209/"/>
    <id>http://yoursite.com/posts/3209/</id>
    <published>2019-10-03T04:43:30.000Z</published>
    <updated>2019-10-03T04:45:50.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis应用⌚️——过滤器与限流"><a href="#Redis应用⌚️——过滤器与限流" class="headerlink" title="Redis应用⌚️——过滤器与限流"></a>Redis应用⌚️——过滤器与限流</h1><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>比如新闻客户端，在推送新的新闻时，要过滤掉已经看过这条新闻的用户。那用什么方法来过滤呢，你可能会想到缓存一个集合，但是当用户量很大的时候，所有用户的阅读历史集合将是一个非常庞大的数据。</p><p>如果你们没有为用户提供“足迹”这样的需求的话，上面所说的功能就可以利用布隆过滤器来实现。</p><h3 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h3><p>布隆过滤器用来判断一个值是否不存在，但是不能完全准确的判断这个值是否一定存在，也就是会有误差，但是我们可以通过参数控制这个误差的概率。可以理解为一个不怎么精确的set结构，过滤时相当于contains方法。</p><p>在Java中，Guava里面提供了布隆过滤器的实现。</p><p>Redis中也提供了布隆过滤器的实现，在Redis 4.0后提供了布隆过滤器作为插件加入到Redis Server中。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>使用<code>bf.add</code> <code>bf.exists</code>指令进行基础操作。</p><p>使用<code>bf.madd``bf.mexists</code>进行批量操作。</p><h2 id="自定义参数的布隆过滤器"><a href="#自定义参数的布隆过滤器" class="headerlink" title="自定义参数的布隆过滤器"></a>自定义参数的布隆过滤器</h2><p>使用<code>bf.reserve</code>有三个参数<code>key</code> <code>error_rate</code> <code>initial_size</code>。</p><p>error_rate越低，所需的空间越大。</p><p>initial_size注意，要尽量设置的准确，一旦元素数量超过initial_size，误判率将会大幅度上升。</p><h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>底层是使用一个大的数组和几个无偏hash函数来实现的，所谓无偏就是可能把hash值算得比较均匀。</p><p>当执行add时，使用几个hash函数分别算出来结果，每个结果对应一个位置，然后将数组这几个位置上的值都设成1。</p><p>当执行exists时，同样将传入的value通过上面的hash函数进行计算，在结果对应的几个位置上判断，如果各位上都是1，即证明这个值存在。</p><blockquote><p>注意，证明值存在是会有误判的，因为存在可能 两个不同的value，通过hash计算出来的结果是完全一致的。</p></blockquote><p>所以只能保证value一定不存在，不能完全保证这个value存在。</p><blockquote><p>当这个数组越大的时候，存储也越稀疏，判断的准确性就会更高，但是占用的空间也会更大。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis应用⌚️——过滤器与限流&quot;&gt;&lt;a href=&quot;#Redis应用⌚️——过滤器与限流&quot; class=&quot;headerlink&quot; title=&quot;Redis应用⌚️——过滤器与限流&quot;&gt;&lt;/a&gt;Redis应用⌚️——过滤器与限流&lt;/h1&gt;&lt;h2 id=&quot;布隆过滤器
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis应用实践—HyperLogLog</title>
    <link href="http://yoursite.com/posts/40227/"/>
    <id>http://yoursite.com/posts/40227/</id>
    <published>2019-10-03T04:43:13.000Z</published>
    <updated>2019-10-03T04:48:02.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis应用实践—HyperLogLog"><a href="#Redis应用实践—HyperLogLog" class="headerlink" title="Redis应用实践—HyperLogLog"></a>Redis应用实践—HyperLogLog</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>适用于精确度要求不是很高的统计需求。</p><p>比如你的网站上线运营了，老板想看看某个页面的uv有多少，你怎么办？</p><ol start="2"><li>给每个页面分配一个zset集合，当一个新用户访问到了，我们把用户id塞进集合就可以了，最后用scard统计集合的数量就ok了。</li></ol><p>这确实是一个比较简单可行的方案，但是如果你们的网站成了爆款，火爆的页面可能有几千万访问，怎么办？买内存条？</p><p>兄弟，大可不必..</p><p>Redis 为我们提供了一个数据结构就是为了给我们实现这样的功能的。</p><p>HyperLogLog在统计这样的数据时非常好用，因为它只占用非常少的空间。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li><p><code>pfadd key userid0</code></p></li><li><p><code>pfcount key</code></p></li><li><p>还可以使用<code>pfmerge</code>合并多个结果 真的是太贴心了</p></li></ul><blockquote><p>拓展阅读：指令为什么用pf开头？是因为HyperLogLog这个数据结构的发明人是Philippe Flajolet ，pf就是他名字的字母缩写。</p></blockquote><blockquote><p>Redis对HyperLogLog的存储进行了优化，在开始是，使用稀疏矩阵存储，空间占用很小，只有当超过了一定的阈值之后才会转变成稠密矩阵来存储，这时它将占用12kb的内存空间。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis应用实践—HyperLogLog&quot;&gt;&lt;a href=&quot;#Redis应用实践—HyperLogLog&quot; class=&quot;headerlink&quot; title=&quot;Redis应用实践—HyperLogLog&quot;&gt;&lt;/a&gt;Redis应用实践—HyperLogLog&lt;/
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis应用实践——位图</title>
    <link href="http://yoursite.com/posts/57747/"/>
    <id>http://yoursite.com/posts/57747/</id>
    <published>2019-10-03T04:43:10.000Z</published>
    <updated>2019-10-03T04:46:42.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis应用实践——位图"><a href="#Redis应用实践——位图" class="headerlink" title="Redis应用实践——位图"></a>Redis应用实践——位图</h1><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>因为只能存取0或1，适用于大量的bool类型数据，比如一年的签到记录，如果使用普通的key/value存储那么用户量上来之后的存储空间时惊人的。</p><p>如果使用位图存储，365天只需要365bit ，只需要46个字节就可以完全存储。</p><ul><li><p>使用setbit命令 <code>setbit key 0 1</code></p></li><li><p>使用getbit命令获取某一位上的值</p></li></ul><p>支持零存整取或者整存零取，零存即一个一个位进行set，整存就是直接set字符串。</p><ul><li><p>使用bitcount进行统计</p></li><li><p>使用bitpos进行查找</p></li></ul><h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><p>在Redis3.2之前，想一次行操作位图的多个位，需要使用管道来进行。但是3.2之后新增了一个强大的指令<code>bitfield</code>， 但一次最多只能操作64位。</p><ul><li>使用biefield进行批量操作 <code>bitfield key set u4/i4 value</code></li></ul><p>上面的u代表无符号数，i代表有符号数。</p><ul><li><code>bitfield key get u4 0</code></li></ul><p>代表从第一位取4位，结果时无符号数。</p><p>bitfield同时支持incrby自增操作。</p><h3 id="birfield中的incrby指令"><a href="#birfield中的incrby指令" class="headerlink" title="birfield中的incrby指令"></a>birfield中的incrby指令</h3><p><code>bitfield key incrby u4 2 1</code>代表从第三位开始，对接下来的4位无符号数+1。</p><p>如果加法发生上溢出或者下溢出，redis默认的策略时折返，比如1111 加一后溢出则这4位变成0000。</p><p>Redis贴心的提供了子指令供我们设置溢出后的策略，默认即是wrap–折返，还提供了fail–失败不执行（返回nil）， sat–饱和截断（保持在最大值）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis应用实践——位图&quot;&gt;&lt;a href=&quot;#Redis应用实践——位图&quot; class=&quot;headerlink&quot; title=&quot;Redis应用实践——位图&quot;&gt;&lt;/a&gt;Redis应用实践——位图&lt;/h1&gt;&lt;h2 id=&quot;基础使用&quot;&gt;&lt;a href=&quot;#基础使用&quot;
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis应用实践——延时队列</title>
    <link href="http://yoursite.com/posts/10625/"/>
    <id>http://yoursite.com/posts/10625/</id>
    <published>2019-10-03T04:42:54.000Z</published>
    <updated>2019-10-03T04:47:01.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis应用实践"><a href="#Redis应用实践" class="headerlink" title="Redis应用实践"></a>Redis应用实践</h1><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li><p>使用list实现</p></li><li><p>rpush, lpop 实现</p></li><li><p>客户端判断如果pop出的结果为空 可以sleep 1秒，防止连续不间断的查询浪费性能</p></li><li><p>使用brpop(blocking)更好的解决上面的问题</p></li><li><p>如果阻塞太久客户端会自动断开链接，所以代码要编写重试机制</p></li></ul><h2 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h2><ul><li><p>使用zset实现，score存放任务的到期处理时间</p></li><li><p>代码中使用zrangebyscore筛选出已到期的任务</p></li><li><p>注意多线程时争抢任务的处理，拿到消息后，尝试调用rem执行删除这条消息，返回结果删除成功后才开始执行任务。</p></li><li><p>优化：可以使用lua脚本将zrangebyscore和zrem变成一个原子操作，避免多次争抢的发生。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis应用实践&quot;&gt;&lt;a href=&quot;#Redis应用实践&quot; class=&quot;headerlink&quot; title=&quot;Redis应用实践&quot;&gt;&lt;/a&gt;Redis应用实践&lt;/h1&gt;&lt;h2 id=&quot;消息队列&quot;&gt;&lt;a href=&quot;#消息队列&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis应用实践——分布式锁</title>
    <link href="http://yoursite.com/posts/16255/"/>
    <id>http://yoursite.com/posts/16255/</id>
    <published>2019-10-03T04:42:48.000Z</published>
    <updated>2019-10-03T04:45:30.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis应用实践——分布式锁"><a href="#Redis应用实践——分布式锁" class="headerlink" title="Redis应用实践——分布式锁"></a>Redis应用实践——分布式锁</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>实现分布式锁的开始需要“占坑”， 使用setnx(set if not exists)命令，如果key存在了，其他客户端尝试set时就会报错；等到当前客户端完成任务执行del后，其他客户端方可进入。</p><p>为了避免拿到锁之后客户端挂了导致永远不能释放锁，加一个过期时间使用expire指令。</p><p>但是setnx 和 expire是两条指令不能原子执行，还是有发生死锁的风险，那怎么解决呢？在Redis 2.8中作者加入了set指令的拓展参数，set lockname true <strong>ex</strong> 5 <strong>nx</strong> , 原生支持了原子操作。</p><h2 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h2><p>上面的方案如果有些任务执行时间过长，那么释放了锁之后，临界区的代码还未执行完，第二个现成又拿到了锁，那么原来的的代码就不能严格的按照串行执行。所以redis分布式锁不推荐用于耗时较长的任务。</p><p>还有要避免其他线程del掉自己的锁，可以使用随机数或者uuid进行匹配，删除时先判断随机数是否一致，不一致不允许删除，但是匹配和删除也不能原子执行，所以这里可以借助lua脚本来执行。</p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>java中也有可重入锁的类ReentrantLock，redis实现需要对set方法进行包装，使用ThreadLocal存放key的加锁次数。但是实际项目中最好不要使用可重入锁，可以通过业务的逻辑上调整完全避免使用可重入锁。</p><h2 id="补充：可重入锁和不可重入锁参考"><a href="#补充：可重入锁和不可重入锁参考" class="headerlink" title="补充：可重入锁和不可重入锁参考"></a>补充：可重入锁和不可重入锁参考</h2><p><a href="https://blog.csdn.net/rickiyeat/article/details/78314451" target="_blank" rel="noopener">https://blog.csdn.net/rickiyeat/article/details/78314451</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis应用实践——分布式锁&quot;&gt;&lt;a href=&quot;#Redis应用实践——分布式锁&quot; class=&quot;headerlink&quot; title=&quot;Redis应用实践——分布式锁&quot;&gt;&lt;/a&gt;Redis应用实践——分布式锁&lt;/h1&gt;&lt;h2 id=&quot;应用&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础数据结构</title>
    <link href="http://yoursite.com/posts/53971/"/>
    <id>http://yoursite.com/posts/53971/</id>
    <published>2019-10-03T04:42:43.000Z</published>
    <updated>2019-10-03T04:44:43.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis基础数据结构"><a href="#Redis基础数据结构" class="headerlink" title="Redis基础数据结构"></a>Redis基础数据结构</h1><h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li><p>key -value键值对(set, get)</p></li><li><p>计数 自增自减(incrby)</p></li></ul><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ul><li><p>链表</p></li><li><p>可以用左进右出或者右进左出实现队列（rpush, lpop)</p></li><li><p>右进右出实现栈（rpush, rpop)</p></li><li><p>慢操作(lindex, ltrim, lrange)</p></li><li><p>快速链表</p></li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><ul><li><p>相当于java中的HashMap</p></li><li><p>key对应一个hash结构 (hset, hget, hlen, hmset)</p></li><li><p>扩容时使用渐进rehash避免阻塞</p></li><li><p>对hash中的单个字段进行计数(hincrby)</p></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ul><li><p>相当于java中的HashSet，即一个所有value为NULL的HashMap</p></li><li><p>自动去重</p></li><li><p>sadd, smembers, sismember, spop</p></li><li><p>scard获取长度</p></li></ul><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><ul><li><p>可以理解为在set基础上为每个value加一个score字段，自动按有序</p></li><li><p>zadd, zrange, zrevrange, zscore, zrangebyscore, zrem</p></li><li><p>zcard获取长度</p></li><li><p>底层使用跳表数据结构，兼顾了查询和插入删除的操作性能。</p></li></ul><h3 id="容器型数据结构的通用规则"><a href="#容器型数据结构的通用规则" class="headerlink" title="容器型数据结构的通用规则"></a>容器型数据结构的通用规则</h3><p>list, set, hash, zset 都是容器型数据结构，他们同享这两条通用规则。</p><ol start="2"><li><p>create if not exists</p></li><li><p>drop if no elements</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis基础数据结构&quot;&gt;&lt;a href=&quot;#Redis基础数据结构&quot; class=&quot;headerlink&quot; title=&quot;Redis基础数据结构&quot;&gt;&lt;/a&gt;Redis基础数据结构&lt;/h1&gt;&lt;h2 id=&quot;基础数据结构&quot;&gt;&lt;a href=&quot;#基础数据结构&quot; cla
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>单链表之查找单链表的中间节点</title>
    <link href="http://yoursite.com/posts/29610/"/>
    <id>http://yoursite.com/posts/29610/</id>
    <published>2019-07-28T04:14:59.000Z</published>
    <updated>2019-07-27T15:13:50.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表之查找单链表的中间节点"><a href="#单链表之查找单链表的中间节点" class="headerlink" title="单链表之查找单链表的中间节点"></a>单链表之查找单链表的中间节点</h1><p>这个实际上之前在反转算法中已经实现过了，这里给大家复习以下思路。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用快指针和慢指针的方法，快指针每次走两步，慢指针每次走一步，当快指针到达尾部的时候，慢指针刚好走过了链表长度的1/2 即指向了中间节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表节点个数为奇数时返回中间节点</span></span><br><span class="line"><span class="comment"> * 为偶数时返回靠右的中间节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findMiddleNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode pSlow = head, pFast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (pFast != <span class="keyword">null</span> &amp;&amp; pFast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pFast = pFast.next.next;</span><br><span class="line">        pSlow = pSlow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pFast == null时为链表个数奇数个，否则为偶数个（取决于快指针最开始从哪里起始）</span></span><br><span class="line">    <span class="keyword">return</span> pFast==<span class="keyword">null</span>? pSlow:pSlow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里会涉及到链表长度是偶数还是奇数的问题，可以看return语句中的三目运算，理解了之后就可以根据自己的需求灵活调整。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单链表之查找单链表的中间节点&quot;&gt;&lt;a href=&quot;#单链表之查找单链表的中间节点&quot; class=&quot;headerlink&quot; title=&quot;单链表之查找单链表的中间节点&quot;&gt;&lt;/a&gt;单链表之查找单链表的中间节点&lt;/h1&gt;&lt;p&gt;这个实际上之前在反转算法中已经实现过了，这里
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单链表之合并两个有序单链表</title>
    <link href="http://yoursite.com/posts/30700/"/>
    <id>http://yoursite.com/posts/30700/</id>
    <published>2019-07-27T14:14:42.000Z</published>
    <updated>2019-07-27T15:13:50.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表之合并两个有序单链表"><a href="#单链表之合并两个有序单链表" class="headerlink" title="单链表之合并两个有序单链表"></a>单链表之合并两个有序单链表</h1><p>题目说的是：合并两个有序的单链表，两个链表既然都有序，那其实我们要做的工作就不是很多了，如果两个链表是无序的，那我们还需要各自对两个链表进行排序再进行合并的操作。</p><h2 id="思路一：遍历实现"><a href="#思路一：遍历实现" class="headerlink" title="思路一：遍历实现"></a>思路一：遍历实现</h2><p>这种实现方式思路比较清晰，代码也比较容易理解，但是较为冗长，我自己没有进行实现，大家可以<a href="https://blog.csdn.net/zm13007310400/article/details/78317821" target="_blank" rel="noopener">点击链接</a>去作者的博客了解一下。</p><h2 id="思路二：递归实现"><a href="#思路二：递归实现" class="headerlink" title="思路二：递归实现"></a>思路二：递归实现</h2><p>不得不说递归的实现方法真的太巧妙了， 几行代码解决问题。递归比较考验我们的抽象问题的能力。</p><blockquote><p>关于递归，有以下几个要点：1. 问题可以分解为多个相同的小问题。2. 每个小问题的处理方式一样的。</p><p>比如我们在电影院，想自己在第几排，那我们可以问前一排的人他在第几排，我们+1就可以了，但是他也不知道在第几排，所以他又去问他前面的人，这样一个接一个问到第一排的人，再一个个返回来。就知道自己第几排了。这就是递归的思路。</p></blockquote><p>合并两个单链表，无非就是不断比较他们当前的节点，将大的（或小的）一个，链接到新的链表上。这里很好的运用了递归把大问题化解成N个小的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归从开始比较两个链表，放入新的链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeTwoLinkedList</span><span class="params">(ListNode h1, ListNode h2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这两个属于递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> h2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> h1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (h1.val &lt;= h2.val) &#123;</span><br><span class="line">        head = h1;</span><br><span class="line">        head.next(mergeTwoLinkedList(h1.next, h2));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        head = h2;</span><br><span class="line">        head.next(mergeTwoLinkedList(h1, h2.next));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>算法专栏的王争老师在递归这节课中有一句话说的很好：不要试图去详细分析递归的运行过程。 研究过递归代码的同学应该都深有体会，稍稍复杂一点，就很容易看晕，放心，这不是因为我们脑容量不够或者比较笨！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单链表之合并两个有序单链表&quot;&gt;&lt;a href=&quot;#单链表之合并两个有序单链表&quot; class=&quot;headerlink&quot; title=&quot;单链表之合并两个有序单链表&quot;&gt;&lt;/a&gt;单链表之合并两个有序单链表&lt;/h1&gt;&lt;p&gt;题目说的是：合并两个有序的单链表，两个链表既然都有序
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单链表之删除链表中倒数第n个节点</title>
    <link href="http://yoursite.com/posts/53885/"/>
    <id>http://yoursite.com/posts/53885/</id>
    <published>2019-07-27T14:14:26.000Z</published>
    <updated>2019-07-27T15:13:50.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表之删除链表中倒数第n个节点"><a href="#单链表之删除链表中倒数第n个节点" class="headerlink" title="单链表之删除链表中倒数第n个节点"></a>单链表之删除链表中倒数第n个节点</h1><p>这篇依然是学习专栏《数据结构与算法之美》链表相关内容的拓展。</p><p>删除链表中倒数第n个节点其实有几种不同的思路，</p><ul><li>可以先遍历一遍记下每个节点的位置，最后再遍历找到倒数第n个节点进行删除</li></ul><p>学习过时间复杂度分析的同学应该就会发现，这里要遍历两次，在最坏的情况下（要删除的是倒数第一个节点），那么消耗的时间就可以达到2T(n).</p><ul><li>使用快慢指针，快指针指向慢指针后的n个节点，然后快慢指针同时前进，直到快指针达到尾部，此时慢指针指向的next就是我们要删除的节点了。</li></ul><p>这种方法我刚看到的时候就觉得挺巧妙的，实现也比较简单，下面附上这种解法的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用快慢指针，快指针比慢指针多n</span></span><br><span class="line"><span class="comment">     * 所以当快指针抵达尾部，满指针的next就是准备删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteNodeFromBack</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空链表</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode pSlow = head;</span><br><span class="line">        ListNode pFast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pFast = pFast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pFast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pFast = pFast.next;</span><br><span class="line">            pSlow = pSlow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        pSlow.next = pSlow.next.next;</span><br><span class="line"><span class="comment">//        System.out.println(pSlow);</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：这里我有些极限情况是没有处理到的，比如n大于了整个链表的长度，为了简洁明了向大家展示这个算法的思路。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单链表之删除链表中倒数第n个节点&quot;&gt;&lt;a href=&quot;#单链表之删除链表中倒数第n个节点&quot; class=&quot;headerlink&quot; title=&quot;单链表之删除链表中倒数第n个节点&quot;&gt;&lt;/a&gt;单链表之删除链表中倒数第n个节点&lt;/h1&gt;&lt;p&gt;这篇依然是学习专栏《数据结构
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单链表之判断表中是否存在环</title>
    <link href="http://yoursite.com/posts/11578/"/>
    <id>http://yoursite.com/posts/11578/</id>
    <published>2019-07-27T14:13:58.000Z</published>
    <updated>2019-07-27T15:13:50.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表之判断表中是否存在环"><a href="#单链表之判断表中是否存在环" class="headerlink" title="单链表之判断表中是否存在环"></a>单链表之判断表中是否存在环</h1><p>这篇依然是学习专栏《数据结构与算法之美》的拓展练习。<br>链表中的环其实是一个挺有趣的问题，如果链表中存在环，对其进行遍历的时候就会发现next永远存在节点，循环往复永远不会终止。所以我们在遍历链表之前还是判断链表中是否存在环安全一点。</p><p>这篇文章不止讲解了如何判断链表中是否存在环，还贴出了链表中非环部分的长度、环的长度、环的起始点这些算法。</p><h2 id="判断链表中是否存在环"><a href="#判断链表中是否存在环" class="headerlink" title="判断链表中是否存在环"></a>判断链表中是否存在环</h2><h3 id="方法一：使用快慢节点"><a href="#方法一：使用快慢节点" class="headerlink" title="方法一：使用快慢节点"></a>方法一：使用快慢节点</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>学习过其他链表算法的同学应该对快慢指针方法很熟悉了，这里也是使用快慢指针的方法。</p><p>原理就是，快指针既然走的比慢指针快，那么当链表中存在环的时候，快慢指针必定在一个位置会相遇，也就是pFast=pSlow。当这个条件一成立我们即可以断定这个链表存在环。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用快慢指针，</span></span><br><span class="line"><span class="comment">     * 快指针每次走两步，慢指针每次走一步</span></span><br><span class="line"><span class="comment">     * 如果链表中有环，那两个指针必定有相遇的时候</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doesLinkedListHasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode pFast = head.next.next,pSlow = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pFast.next != <span class="keyword">null</span> &amp;&amp; pSlow.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pFast == pSlow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pFast = pFast.next.next;</span><br><span class="line">            pSlow = pSlow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：使用Map将节点作为key"><a href="#方法二：使用Map将节点作为key" class="headerlink" title="方法二：使用Map将节点作为key"></a>方法二：使用Map将节点作为key</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这里就是利用的Map的key唯一的特性，遍历链表，当发现map中已经存在当前遍历到的节点时，即我们是再一次来到了这个节点，证明链表存在环。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Map将每一个走过的节点存进去</span></span><br><span class="line"><span class="comment"> * 在存之前get一下，如果get有值，说明之前存过，即证明有环</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doesLinkedListHasCycle1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ListNode, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    ListNode p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(p)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(p, <span class="keyword">null</span>);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找环的起点"><a href="#查找环的起点" class="headerlink" title="查找环的起点"></a>查找环的起点</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>查找环的起点的前提就是链表要存在环，所以此算法的前半部分就是利用了前面的快慢指针判断法，不同的是，当确定存在环的时候我们即跳出循环。</p><p>这里有一个推导过程，我参考别人的博客。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/hexo_blog/20190726/01.png" alt="推导过程" title>                </div>                <div class="image-caption">推导过程</div>            </figure><blockquote><p>参考：<a href="https://blog.csdn.net/jiaobuchong/article/details/84727007" target="_blank" rel="noopener">https://blog.csdn.net/jiaobuchong/article/details/84727007</a></p></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>看懂了上面的推导过程，我们直接按照其实现对应的代码就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找链表环的起点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null代表没有环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findCycleHead</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode pFast = head, pSlow = head;</span><br><span class="line">    <span class="comment">// 循环直到快慢指针相遇</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        pFast = pFast.next.next;</span><br><span class="line">        pSlow = pSlow.next;</span><br><span class="line">        <span class="keyword">if</span> (pFast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pFast == pSlow) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让快指针等于头节点，然后各自以1 的步长继续前进，直到再次相遇</span></span><br><span class="line">    <span class="comment">// 相遇点即为环的起始点</span></span><br><span class="line">    pFast = head;</span><br><span class="line">    <span class="comment">// 可以顺便计算出非环部分的长度</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        pFast = pFast.next;</span><br><span class="line">        pSlow = pSlow.next;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (pFast == pSlow) &#123;</span><br><span class="line">            System.out.println(<span class="string">"length of not cycle in this LinkedList: "</span> + i);</span><br><span class="line">            <span class="keyword">return</span> pFast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算环的长度"><a href="#计算环的长度" class="headerlink" title="计算环的长度"></a>计算环的长度</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这个算法依然用到了快慢指针，类比到生活中就像是两个人在操场跑步，一个人跑的快一个人跑的慢一点。</p><p>我们现在假设快指针叫快男，慢指针叫慢哥</p><p>在计算环长度这个算法中，快男和慢男同时在起点起跑，当快男第一次追上慢哥时（即快男已经领先一圈，假设这里时位置a），这是慢哥停下站在原地不动，快男继续跑，当快男再一次追上慢哥的时候（快男转了一圈回到位置a），所以刚刚快男走过的长度就是环的长度。类比到代码里应该就很好理解了。</p><blockquote><p>要注意的是极端条件的处理，防止异常情况的发生，让代码尽可能的健壮</p></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算环的长度，没有环就返回0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCycleLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pFast = head, pSlow = head;</span><br><span class="line">    <span class="comment">// 直到相遇</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        pFast = pFast.next.next;</span><br><span class="line">        pSlow = pSlow.next;</span><br><span class="line">        <span class="keyword">if</span> (pFast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pFast == pSlow) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pFast停下，pSlow继续走，直到再次相遇 pSlow走过的长度即为环的长度</span></span><br><span class="line">    <span class="keyword">int</span> cycleLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        pSlow = pSlow.next;</span><br><span class="line">        cycleLength++;</span><br><span class="line">        <span class="keyword">if</span> (pSlow == pFast) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cycleLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单链表之判断表中是否存在环&quot;&gt;&lt;a href=&quot;#单链表之判断表中是否存在环&quot; class=&quot;headerlink&quot; title=&quot;单链表之判断表中是否存在环&quot;&gt;&lt;/a&gt;单链表之判断表中是否存在环&lt;/h1&gt;&lt;p&gt;这篇依然是学习专栏《数据结构与算法之美》的拓展练习。
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单链表之：反转算法</title>
    <link href="http://yoursite.com/posts/55684/"/>
    <id>http://yoursite.com/posts/55684/</id>
    <published>2019-07-20T07:13:12.000Z</published>
    <updated>2019-07-20T07:51:45.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表之：链表反转算法"><a href="#单链表之：链表反转算法" class="headerlink" title="单链表之：链表反转算法"></a>单链表之：链表反转算法</h1><p>上一篇博客讲述了一些链表的知识以及判断是否为回文串的算法，详见<a href="/posts/64872/">如何判断一个单链表是否为回文串？</a></p><h2 id="一、递归方法"><a href="#一、递归方法" class="headerlink" title="一、递归方法"></a>一、递归方法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从头节点开始，递归调用头节点的next，实际上就是从尾节点一次反转各个节点的指针指向。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160411103016811?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="来源：见参考" title>                </div>                <div class="image-caption">来源：见参考</div>            </figure><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种，递归 在反转当前节点之前先反转后续节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ListNode <span class="title">reverse0</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head ==<span class="keyword">null</span> || head.next ==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归 从最后一个节点开始反转</span></span><br><span class="line">        ListNode reHead = reverse0(head.next);</span><br><span class="line">        head.next.next = head;<span class="comment">// 自己的下一个的下一个指向自己就是反转过来了</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;<span class="comment">// 清空自己的next指针 相当于断开链表</span></span><br><span class="line">        <span class="keyword">return</span> reHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二、非递归方法"><a href="#二、非递归方法" class="headerlink" title="二、非递归方法"></a>二、非递归方法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>从前到后，每两个节点依次进行反转。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160411103425114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="来源见参考" title>                </div>                <div class="image-caption">来源见参考</div>            </figure><h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不使用递归的方法，从前向后进行两两进行交换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ListNode <span class="title">reverse1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode prev = head;<span class="comment">// 代表前一个节点</span></span><br><span class="line">    ListNode cur = head.next;<span class="comment">// 代表当前节点</span></span><br><span class="line">    ListNode temp = <span class="keyword">null</span>;<span class="comment">// 代表下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        temp = cur.next;<span class="comment">// 暂存下一个节点，后面赋值回来</span></span><br><span class="line">        cur.next = prev;<span class="comment">// 最关键的一句，当前节点next指向前一个节点，即反转了方向</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针 整体向后移，当前节点变成前节点，下一节点变成当前节点</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListNode"><a href="#ListNode" class="headerlink" title="ListNode"></a>ListNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// builder mode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">next</span><span class="params">(ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">", next="</span> + next +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="string">'a'</span>);</span><br><span class="line">        head.next(<span class="keyword">new</span> ListNode(<span class="string">'b'</span>)).next(<span class="keyword">new</span> ListNode(<span class="string">'d'</span>));</span><br><span class="line"><span class="comment">//        System.out.println(reverse0(head));</span></span><br><span class="line">        System.out.println(reverse1(head));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://blog.csdn.net/guyuealian/article/details/51119499#commentsedit" target="_blank" rel="noopener">https://blog.csdn.net/guyuealian/article/details/51119499#commentsedit</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单链表之：链表反转算法&quot;&gt;&lt;a href=&quot;#单链表之：链表反转算法&quot; class=&quot;headerlink&quot; title=&quot;单链表之：链表反转算法&quot;&gt;&lt;/a&gt;单链表之：链表反转算法&lt;/h1&gt;&lt;p&gt;上一篇博客讲述了一些链表的知识以及判断是否为回文串的算法，详见&lt;a 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>专栏学习笔记：为什么很多编程语言中数组都从0开始编号？</title>
    <link href="http://yoursite.com/posts/7261/"/>
    <id>http://yoursite.com/posts/7261/</id>
    <published>2019-07-20T03:14:32.000Z</published>
    <updated>2019-07-20T03:44:49.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="专栏学习笔记：为什么很多编程语言中数组都从0开始编号？"><a href="#专栏学习笔记：为什么很多编程语言中数组都从0开始编号？" class="headerlink" title="专栏学习笔记：为什么很多编程语言中数组都从0开始编号？"></a>专栏学习笔记：为什么很多编程语言中数组都从0开始编号？</h1><h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>除了数组，链表、队列、栈等也是线性表结构。</p><h3 id="非线性表"><a href="#非线性表" class="headerlink" title="非线性表"></a>非线性表</h3><p>二叉树、堆、图等都是非线性表，之所以叫非先行是因为 数据在非线性表中并不是简单的前后关系。</p><h2 id="数组越界问题在java和c中的差别"><a href="#数组越界问题在java和c中的差别" class="headerlink" title="数组越界问题在java和c中的差别"></a>数组越界问题在java和c中的差别</h2><p>由于在c语言中，只要不是受限的内存，所有的内存空间都可以是自由访问的。所以当C语言中数组的下标超过了数组的长度，并不会直接出错，而是会出现其他奇怪的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这段C代码，由于循环条件写成了&lt;=3所以 在执行3次以后，数组下标访问越界，这个会造成死循环一致输出hello world问题，这里由于涉及到其他方面的原理，暂不深究，这里贴出作者的讲解和其他读者的评论给大家参考。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/hexo_blog/20190720/02.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/hexo_blog/20190720/03.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/hexo_blog/20190720/04.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>而在java中的话，虚拟机就会抛出数组越界异常。</p><h2 id="高级语言中的容器"><a href="#高级语言中的容器" class="headerlink" title="高级语言中的容器"></a>高级语言中的容器</h2><p>以java为例，作为java程序员可能每天都在使用的ArrayList，就是对数组进行一定程度的封装，比如自动扩容，迭代器等 方便程序员的使用。</p><h2 id="容器与数组的选择"><a href="#容器与数组的选择" class="headerlink" title="容器与数组的选择"></a>容器与数组的选择</h2><p>既然容器这么好用，那数组是不是就全无用武之地了呢？</p><p>当然不是，有些时候，使用数组会更加合适。下面列出的几种常见的情况：</p><ol><li><p>由于java的ArrayList只能存储Integer、Float等包装类型，不能存储基本类型， 在自动拆箱装箱会有一定的性能消耗。</p></li><li><p>如果事先已知数据的大小，那么使用数组会更加方便，在声明数组的时候直接指定好它的大小。研究过ArrayList源代码的同学应该知道，ArraylList底层也是数组，如果不指定初始长度的话，每一次快满了的时候都会自动扩容，而扩容就是使用了数组复制，想象一下，如果你的List有1G的数据，容器扩容到1.5G，就要把这1G的数据复制过去，是不是想想都很费时间。当然，使用ArrayList也可以事先指定好一个大小。关于这一块的源码分析可以看别人的另外一篇文章：<a href="https://blog.csdn.net/fighterandknight/article/details/61240861" target="_blank" rel="noopener">https://blog.csdn.net/fighterandknight/article/details/61240861</a> </p></li></ol><h2 id="为什么数组从0开始编号"><a href="#为什么数组从0开始编号" class="headerlink" title="为什么数组从0开始编号"></a>为什么数组从0开始编号</h2><p>从存储模型的角度来看，数组的下标说是偏移量更为准确，它的英文offset也正是此意。偏移量就表示了相对于首地址偏移了多少，学过C语言的同学应该记得，如果把数组赋给一个变量， 那它的指针就是指向数组的头节点，而头节点的偏移量就是0。是不是很好理解了？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;专栏学习笔记：为什么很多编程语言中数组都从0开始编号？&quot;&gt;&lt;a href=&quot;#专栏学习笔记：为什么很多编程语言中数组都从0开始编号？&quot; class=&quot;headerlink&quot; title=&quot;专栏学习笔记：为什么很多编程语言中数组都从0开始编号？&quot;&gt;&lt;/a&gt;专栏学习笔
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何判断一个单链表是否为回文串？</title>
    <link href="http://yoursite.com/posts/64872/"/>
    <id>http://yoursite.com/posts/64872/</id>
    <published>2019-07-20T02:58:10.000Z</published>
    <updated>2019-07-20T02:59:10.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何判断一个单链表是否为回文串？"><a href="#如何判断一个单链表是否为回文串？" class="headerlink" title="如何判断一个单链表是否为回文串？"></a>如何判断一个单链表是否为回文串？</h1><h2 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h2><p>这道题是极客时间专栏数据结构与算法之美《06 | 链表（上）：如何实现LRU缓存淘汰算法?》里面的一道思考题，同时也是leetcode上的一道题目，原题为：<a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-linked-list/</a></p><p>由于我在算法方面的基础比较薄弱，所以直接去看了别人的解决方法，也花了好一会才看懂，加上照着敲一遍代码，跑debug 最终才完全理解了这种解法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>里面的注释都是我在思考过后补充上去的，相信大家理解了之后再删掉注释也会感觉豁然开朗。</p><ul><li><p>我自己给ListNode使用了builder模式，方便测试的时候输入数据（其实不算是严格的builder模式，真正的builder是返回对象this，这里是返回了next的引用）</p></li><li><p>我的注释可能影响你的思考，可以尝试忽略我的注释或者删掉，自己思考</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a singly linked list, determine if it is a palindrome.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromeLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// solution</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次跳两个 变相控制了循环的次数，相当于除2</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">// 临时变量 暂存</span></span><br><span class="line">            ListNode next = slow.next;</span><br><span class="line">            <span class="comment">// 一开始prev为空时：slow变成了头节点；到后面就是把本来在prev的元素变成它的next</span></span><br><span class="line">            slow.next = prev;</span><br><span class="line">            prev = slow;</span><br><span class="line"></span><br><span class="line">            slow = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束 prev就是链表前半部分反序后的链表，slow就是原链表的后半部分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链表节点为偶数时刚好除尽，为奇数时这里的fast就是最后一个节点</span></span><br><span class="line">        <span class="comment">// 节点个数为奇数时则不用比较中间节点 所以这里.next跳过了中间节点</span></span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次比较，如果有不同直接返回false</span></span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slow.val != prev.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="string">'a'</span>);</span><br><span class="line">        head.next(<span class="keyword">new</span> ListNode(<span class="string">'b'</span>)).next(<span class="keyword">new</span> ListNode(<span class="string">'a'</span>));</span><br><span class="line">        System.out.println(head);</span><br><span class="line">        System.out.println(isPalindrome(head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// builder mode</span></span><br><span class="line">    <span class="function">ListNode <span class="title">next</span><span class="params">(ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">", next="</span> + next +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/hexo_blog/20190720/WX20190720-104751%402x.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何判断一个单链表是否为回文串？&quot;&gt;&lt;a href=&quot;#如何判断一个单链表是否为回文串？&quot; class=&quot;headerlink&quot; title=&quot;如何判断一个单链表是否为回文串？&quot;&gt;&lt;/a&gt;如何判断一个单链表是否为回文串？&lt;/h1&gt;&lt;h2 id=&quot;前情&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Tomcat之一：Tomcat基础架构</title>
    <link href="http://yoursite.com/posts/24480/"/>
    <id>http://yoursite.com/posts/24480/</id>
    <published>2019-07-06T09:26:18.000Z</published>
    <updated>2019-07-06T09:00:30.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Tomcat之一：Tomcat基础架构"><a href="#深入理解Tomcat之一：Tomcat基础架构" class="headerlink" title="深入理解Tomcat之一：Tomcat基础架构"></a>深入理解Tomcat之一：Tomcat基础架构</h1><h2 id="Tomcat的定义（来自wiki百科）"><a href="#Tomcat的定义（来自wiki百科）" class="headerlink" title="Tomcat的定义（来自wiki百科）"></a>Tomcat的定义（来自wiki百科）</h2><p>Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个<strong>Servlet容器</strong>，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如**Tomcat管理和控制平台、安全域管理和Tomcat阀等。</p><p>由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。</p><h2 id="Http服务器与应用服务器"><a href="#Http服务器与应用服务器" class="headerlink" title="Http服务器与应用服务器"></a>Http服务器与应用服务器</h2><p>之前在技术讨论群里看到一个群友提问：nginx和tomcat有什么区别呀？其实提出这种问题就可以得知他对两个服务器的基础概念都还不是很清晰。 严格来讲，Nginx、Apache这些叫做Http Server； 而Tomcat是Application Server，更准确的说，是一个Servlet、Jsp容器。 一个 <strong>HTTP Server 关心的是 HTTP 协议层面的传输和访问控制</strong>，所以在 Apache/Nginx 上你可以看到<strong>代理、负载均衡</strong>等功能。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。一个 HTTP Server 始终只是把服务器上的文件如实的通过 HTTP 协议传输给客户端。 对于 Tomcat 来说，就是需要<strong>提供 JSP/Sevlet 运行需要的标准类库、Interface 等</strong>。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。 回到上面的问题，在我的理解看来，Nginx更像一个协调管理者的角色，而Tomcat用“容器”这个词语形容它会更加形象贴切一点。</p><h2 id="Tomcat的整体架构"><a href="#Tomcat的整体架构" class="headerlink" title="Tomcat的整体架构"></a>Tomcat的整体架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images-cdn.shimo.im/HXQSiPn6iJ0hiTzk/image.png!original" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Tomcat最顶层的容器是Server， 代表整个服务器，从上图可以看出一个 Server至少包含 一个Service，用于具体提供服务。</p><h3 id="两个主要组件"><a href="#两个主要组件" class="headerlink" title="两个主要组件"></a>两个主要组件</h3><h4 id="Connecter"><a href="#Connecter" class="headerlink" title="Connecter"></a>Connecter</h4><p>用于<strong>处理连接相关</strong>的事，并提供<strong>Socket</strong>与Request和Response相关的转化;</p><h5 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h5><p>一个Connecter将在某个指定的<strong>端口上侦听客户请求，接收浏览器的发过来的 tcp 连接请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据</strong>，然后会产生一个线程来处理这个请求并把产生的 Request 和 Response 对象传给处理Engine(Container中的一部分)，从Engine出获得响应并返回客户。 Tomcat中有两个经典的Connector，</p><ul><li><p>一个直接侦听来自Browser的HTTP请求，</p></li><li><p>另外一个来自其他的WebServer请求。</p></li></ul><p>HTTP/1.1 Connector在端口8080处侦听来自客户Browser的HTTP请求，AJP/1.3 Connector在端口8009处侦听其他Web Server（其他的HTTP服务器）的Servlet/JSP请求。</p><p>Connector 最重要的功能就是接收连接请求然后分配线程让 Container 来处理这个请求，所以这必然是多线程的，多线程的处理是 Connector 设计的核心。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images-cdn.shimo.im/HF9ScgG4RrsO003A/image.png!thumbnail" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Connector 中具体是用<strong>ProtocolHandler</strong> 来处理请求的，不同的ProtocolHandler 代表不同的连接类型，比如， Http11Protocol 使用的是普通Socket 来连接的， Http 11 NioProtocol 使用的是NioSocket 来连接的。</p><p>ProtocolHandler 里面有3 个非常重要的组件： Endpoint 、Processor 和Adapter。</p><ul><li><p><strong>Endpoint</strong>用于处理底层Socket 的网络连接，</p><ul><li><p><strong>Acceptor</strong> 用于监昕请求</p></li><li><p><strong>AsyncTimeout</strong> 用于检查异步request 的超时</p></li><li><p><strong>Handler</strong> 用于处理接收到的Socket，在内部调用了Processor 进行处理。</p></li></ul></li><li><p><strong>Processor</strong> 用于将Endpoint 接收到的Socket 封装成Request,</p></li><li><p><strong>Adapter</strong> 用于将封装好的Request 交给Container 进行具体处理。</p></li></ul><p><strong><em>也就是说Endpoint用来实现TCP/IP 协议， Processor 用来实现HTTP 协议， Adapter 将请求适配到Servlet 容器进行具体处理。</em></strong></p><h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4><p>用于<strong>封装和管理Servlet</strong>，以及具体<strong>处理Request请求</strong>；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images-cdn.shimo.im/pZ1MD2LFC1ojN7Fa/image.png!thumbnail" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器。</p><p>4个子容器的作用分别是：</p><p>（1）Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</p><p>（2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</p><p>（3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；</p><p>（4）Wrapper：每一Wrapper封装着一个Servlet；</p><h3 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h3><ul><li><p><strong>Jasper</strong>：负责jsp页面的解析，jsp属性的验证,同时负责将jsp动态转换为java代码并编译成class。</p></li><li><p><strong>Naming</strong>：资源管理，负责数据库连接池、EJB、mail等通过JDNI获取的内容。</p></li><li><p><strong>Session</strong>：会话管理的组件</p></li><li><p><strong>Logging</strong>：日志相关</p></li><li><p><strong>JMX</strong>：性能监控等</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解Tomcat之一：Tomcat基础架构&quot;&gt;&lt;a href=&quot;#深入理解Tomcat之一：Tomcat基础架构&quot; class=&quot;headerlink&quot; title=&quot;深入理解Tomcat之一：Tomcat基础架构&quot;&gt;&lt;/a&gt;深入理解Tomcat之一：Tomc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解Tomcat之二：自己动手实现一个简单的Tomcat</title>
    <link href="http://yoursite.com/posts/6083/"/>
    <id>http://yoursite.com/posts/6083/</id>
    <published>2019-07-06T09:26:18.000Z</published>
    <updated>2019-07-06T09:00:30.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Tomcat之二：自己动手实现一个简单的Tomcat"><a href="#深入理解Tomcat之二：自己动手实现一个简单的Tomcat" class="headerlink" title="深入理解Tomcat之二：自己动手实现一个简单的Tomcat"></a>深入理解Tomcat之二：自己动手实现一个简单的Tomcat</h1><p>学习一个新的知识的过程就是 看别人的文章、听别人讲、自己查资料、自己给别人讲。我们对于新知识的认识成都以及理解深度都是在整个过程中不断的加深的。所以我一直提倡大家要乐于分享，当你给别人用组织系统化的语言或者文章将你头脑中的知识输出来，你就会发现，你对之前知识的理解又加深了一个程度。 而这一篇手写tomcat，其实也是我在学习tomcat架构的过程中，模仿别人的代码自己再手敲一遍，最后将思路和实现过程整理成文，输出给大家。</p><h2 id="主要需求"><a href="#主要需求" class="headerlink" title="主要需求"></a>主要需求</h2><ul><li><p>监听请求端口</p></li><li><p>封装请求和返回</p></li><li><p>对请求进行处理</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/19070601.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上面就是mini tomcat的类图</p><h2 id="各个类"><a href="#各个类" class="headerlink" title="各个类"></a>各个类</h2><h3 id="MyRequest"><a href="#MyRequest" class="headerlink" title="MyRequest"></a>MyRequest</h3><pre><code>自己封装的请求类，相当于servlet中的HttpRequest。</code></pre><ul><li><p>inputStream来自于socket的输入流，用浏览器访问的时候就会包含了整个请求的报文</p></li><li><p>解析http请求头的第一行 拿出协议中的 GET 或者 POST 还有请求url</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己封装的请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRequest</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String httpRequest = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] requestBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> length = inputStream.read(requestBytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            httpRequest = <span class="keyword">new</span> String(requestBytes, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析内容</span></span><br><span class="line">        <span class="comment">// 第一行是http头部内容</span></span><br><span class="line">        String httpHead = httpRequest.split(<span class="string">"\n"</span>)[<span class="number">0</span>];</span><br><span class="line">        url = httpHead.split(<span class="string">"\\s"</span>)[<span class="number">1</span>];</span><br><span class="line">        method = httpHead.split(<span class="string">"\\s"</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"接收到请求-------》"</span>);</span><br><span class="line">        System.out.println(<span class="string">"请求信息 ："</span> + toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"url: "</span> + url + <span class="string">", method: "</span> + method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyResponse"><a href="#MyResponse" class="headerlink" title="MyResponse"></a>MyResponse</h3><ul><li>要点在于手动按照http协议的格式进行响应，这样浏览器才可以识别</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己封装的响应</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResponse</span><span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputStream = outputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String content)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outputStream!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            StringBuffer httpResponse = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照http响应格式输出</span></span><br><span class="line">            httpResponse.append(<span class="string">"HTTP/1.1 200 OK\n"</span>)</span><br><span class="line">                    .append(<span class="string">"Content-Type: text/html\n"</span>)</span><br><span class="line">                    .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                    .append(<span class="string">"&lt;html&gt;&lt;body&gt;"</span>)</span><br><span class="line">                    .append(content)</span><br><span class="line">                    .append(<span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"返回信息："</span>+httpResponse.toString());</span><br><span class="line"></span><br><span class="line">            outputStream.write(httpResponse.toString().getBytes());</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyServlet"><a href="#MyServlet" class="headerlink" title="MyServlet"></a>MyServlet</h3><p>抽象的Servlet，可以继承它来有很多不同的实现。</p><ul><li>service 方法根据请求的方法分发到get或者post进行处理，这里与</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己封装的Servlet</span></span><br><span class="line"><span class="comment"> * 继承后做不同的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(MyRequest httpRequest, MyResponse httpResponse)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(MyRequest httpRequest, MyResponse httpResponse)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(MyRequest request, MyResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"POST"</span>.equalsIgnoreCase(request.getMethod())) &#123;</span><br><span class="line">                doPost(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"GET"</span>.equalsIgnoreCase(request.getMethod())) &#123;</span><br><span class="line">                doGet(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HelloServlet"><a href="#HelloServlet" class="headerlink" title="HelloServlet"></a>HelloServlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet的实现类，在post get中添加具体的业务逻辑</span></span><br><span class="line"><span class="comment"> * 以前使用servlet编程的时候也是这样的实现方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">MyServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(MyRequest httpRequest, MyResponse httpResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            httpResponse.write(<span class="string">"get method in hello servlet !!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(MyRequest httpRequest, MyResponse httpResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            httpResponse.write(<span class="string">"post method in hello servlet"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServletMapping"><a href="#ServletMapping" class="headerlink" title="ServletMapping"></a>ServletMapping</h3><p>其实是一个Bean，简单封装了配置信息，方便我们读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String servletName;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String clazz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServletMapping</span><span class="params">(String servletName, String url, String clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servletName = servletName;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> servletName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServletName</span><span class="params">(String servletName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servletName = servletName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClazz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClazz</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServletMappingConfig"><a href="#ServletMappingConfig" class="headerlink" title="ServletMappingConfig"></a>ServletMappingConfig</h3><p>存着一个列表来保存配置，真正tomcat也不是这样实现的。我们只是为了效果方便实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里由于是demo 采用简洁的方式先进行配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletMappingConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;ServletMapping&gt; config = <span class="keyword">new</span> ArrayList&lt;ServletMapping&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在真正的tomcat中是扫描web.xml的配置来初始化ServletMapping</span></span><br><span class="line">   <span class="keyword">static</span>  &#123;</span><br><span class="line">        config.add(<span class="keyword">new</span> ServletMapping(<span class="string">"hello"</span>, <span class="string">"/hello"</span>, <span class="string">"com.practice.HelloServlet"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyTomcat"><a href="#MyTomcat" class="headerlink" title="MyTomcat"></a>MyTomcat</h3><p>minitomcat的核心类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTomcat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; mapping = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTomcat</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用socket不断等候接收新的请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initservletMappings();</span><br><span class="line"></span><br><span class="line">        ServerSocket socket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"Tomcat 启动成功～～"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket accept = socket.accept();</span><br><span class="line">                InputStream inputStream = accept.getInputStream();</span><br><span class="line">                OutputStream outputStream = accept.getOutputStream();</span><br><span class="line"></span><br><span class="line">                MyRequest myRequest = <span class="keyword">new</span> MyRequest(inputStream);</span><br><span class="line">                MyResponse myResponse = <span class="keyword">new</span> MyResponse(outputStream);</span><br><span class="line"></span><br><span class="line">                dispatch(myRequest, myResponse);</span><br><span class="line"></span><br><span class="line"><span class="comment">//                socket.close();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置文件初始化servletMapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initservletMappings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ServletMapping servletMapping : ServletMappingConfig.config) &#123;</span><br><span class="line">            mapping.put(servletMapping.getUrl(), servletMapping.getClazz());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置找到对应的Servlet类，使用反射创建实例处理请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(MyRequest request, MyResponse response)</span> </span>&#123;</span><br><span class="line">        String url = request.getUrl();</span><br><span class="line">        String clazz = mapping.get(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clazz==<span class="keyword">null</span> || clazz==<span class="string">""</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到请求对应的链接:"</span> + url);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;MyServlet&gt; aClass = (Class&lt;MyServlet&gt;) Class.forName(clazz);</span><br><span class="line">            MyServlet myServlet = aClass.newInstance();</span><br><span class="line">            myServlet.service(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"不存在该类"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动tomcat</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyTomcat(<span class="number">8081</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们运行main方法，在浏览器中访问localhost:8081/hello 就可以看到效果啦！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/2019070602.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个tomcat很mini ，只简单实现了基本的功能，大家可以在这个基础上不断添加其他的功能，让这个minitomcat越来越接近真正的tomct！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解Tomcat之二：自己动手实现一个简单的Tomcat&quot;&gt;&lt;a href=&quot;#深入理解Tomcat之二：自己动手实现一个简单的Tomcat&quot; class=&quot;headerlink&quot; title=&quot;深入理解Tomcat之二：自己动手实现一个简单的Tomcat&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring中的事件简述与Guava的EventBus</title>
    <link href="http://yoursite.com/posts/38349/"/>
    <id>http://yoursite.com/posts/38349/</id>
    <published>2019-06-11T09:26:18.000Z</published>
    <updated>2019-06-11T09:27:22.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring中的事件简述与Guava的EventBus"><a href="#Spring中的事件简述与Guava的EventBus" class="headerlink" title="Spring中的事件简述与Guava的EventBus"></a>Spring中的事件简述与Guava的EventBus</h1><h2 id="Spring的事件"><a href="#Spring的事件" class="headerlink" title="Spring的事件"></a>Spring的事件</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><ol><li><p>org.springframework.context.ApplicationEvent</p></li><li><p>org.springframework.context.ApplicationListener</p></li></ol><p>使用容器触发事件，applicationContext发布事件。</p><h3 id="简单实现逻辑"><a href="#简单实现逻辑" class="headerlink" title="简单实现逻辑"></a>简单实现逻辑</h3><ol><li><p>自定义订阅和通知事件，继承ApplicationEvent</p></li><li><p>定义事件监听器，实现ApplicationListener</p></li><li><p>使用容器发布事件（订阅、通知）</p></li></ol><h3 id="拓展-EventListener注解"><a href="#拓展-EventListener注解" class="headerlink" title="拓展@EventListener注解"></a>拓展@EventListener注解</h3><p>为了加强@EventListener的功能，Spring 4.2开始支持使用SpEL表达式定义事件触发的条件。</p><p>下面为使用了该注解的的一个实例：</p><p>Event：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isImport;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span><span class="params">(Object source, <span class="keyword">boolean</span> isImport)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.isImport = isImport;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isImport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isImport;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImport</span><span class="params">(<span class="keyword">boolean</span> anImport)</span> </span>&#123;</span><br><span class="line">        isImport = anImport;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TestEvent&#123;"</span> +</span><br><span class="line">                <span class="string">"isImport="</span> + isImport +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Listener:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当isImport为true的时候才会打印</span></span><br><span class="line">    <span class="meta">@EventListener</span>(condition=<span class="string">"#testEvent.isImport"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestEventTest</span><span class="params">(TestEvent testEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==============TestEvent=============="</span> + testEvent.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展Google-Guava中的EventBus"><a href="#拓展Google-Guava中的EventBus" class="headerlink" title="拓展Google Guava中的EventBus"></a>拓展Google Guava中的EventBus</h3><p>GoogleGuava是谷歌在日常开发过程中总结积累出来的一个类库，包含了许多常用的工具等。</p><p>Guava的优点：</p><ul><li>高效设计良好的API，被Google的开发者设计，实现和使用</li><li>遵循高效的java语法实践</li><li>使代码更刻度，简洁，简单</li><li>节约时间，资源，提高生产力</li></ul><p>Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：</p><ul><li>集合 [collections]</li><li>缓存 [caching]</li><li>原生类型支持 [primitives support]</li><li>并发库 [concurrency libraries]</li><li>通用注解 [common annotations]</li><li>字符串处理 [string processing]</li><li>I/O 等等。</li></ul><p>这里我们主要介绍Guava中的事件总线EventBus。使用Guava的事件总线就不用再像上面Spring中的继承实现接口的方法。只需要在指定的事件处理方法上加@Subscribe注解即可。</p><p>消息封装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span><span class="params">(<span class="keyword">int</span> message)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        System.out.println(<span class="string">"event message:"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息接收类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> lastMessage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(TestEvent event)</span> </span>&#123;</span><br><span class="line">        lastMessage = event.getMessage();</span><br><span class="line">        System.out.println(<span class="string">"Message:"</span>+lastMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLastMessage</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> lastMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类及输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEventBus</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReceiveEvent</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventBus eventBus = <span class="keyword">new</span> EventBus(<span class="string">"test"</span>);</span><br><span class="line">        EventListener listener = <span class="keyword">new</span> EventListener();</span><br><span class="line"></span><br><span class="line">        eventBus.register(listener);</span><br><span class="line"></span><br><span class="line">        eventBus.post(<span class="keyword">new</span> TestEvent(<span class="number">200</span>));</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> TestEvent(<span class="number">300</span>));</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> TestEvent(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">                                    System.out.println(<span class="string">"LastMessage:"</span>+listener.getLastMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出信息</span></span><br><span class="line">event message:<span class="number">200</span></span><br><span class="line">Message:<span class="number">200</span></span><br><span class="line">event message:<span class="number">300</span></span><br><span class="line">Message:<span class="number">300</span></span><br><span class="line">event message:<span class="number">400</span></span><br><span class="line">Message:<span class="number">400</span></span><br><span class="line">LastMessage:<span class="number">400</span></span><br></pre></td></tr></table></figure><p>以上即是EventBus的简单使用。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p><a href="https://shimo.im/docs/z7ggA56biOAfAdht/read" target="_blank" rel="noopener">https://shimo.im/docs/z7ggA56biOAfAdht/read</a></p><p><a href="https://www.cnblogs.com/peida/p/EventBus.html" target="_blank" rel="noopener">https://www.cnblogs.com/peida/p/EventBus.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring中的事件简述与Guava的EventBus&quot;&gt;&lt;a href=&quot;#Spring中的事件简述与Guava的EventBus&quot; class=&quot;headerlink&quot; title=&quot;Spring中的事件简述与Guava的EventBus&quot;&gt;&lt;/a&gt;Sprin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于二分查找（折半查找）的即记录</title>
    <link href="http://yoursite.com/posts/1/"/>
    <id>http://yoursite.com/posts/1/</id>
    <published>2019-06-05T07:36:18.000Z</published>
    <updated>2019-06-05T07:47:40.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于二分查找（折半查找）的即记录"><a href="#关于二分查找（折半查找）的即记录" class="headerlink" title="关于二分查找（折半查找）的即记录"></a>关于二分查找（折半查找）的即记录</h2><p>之前其实也学习过二分查找的理念，但是一直有一个模糊的地方就是中间元素的选取。</p><p>二分查找需要的数组需要是有序的。</p><h3 id="二分查找的步骤"><a href="#二分查找的步骤" class="headerlink" title="二分查找的步骤"></a>二分查找的步骤</h3><ol><li><p>确定数组的中间元素</p></li><li><p>将待查找元素与中间元素比较</p></li><li><p>如果大于中间元素，则到右边的数组查找，反之同理</p></li><li><p>如果中间元素等于待查找元素，那么查找成功。</p></li></ol><p>之前一直迷惑的一点就是第一步当中的中间元素的选取，因为数组会有两种情况，一种是元素的个数为偶数，另一种是数组元素个数为奇数。</p><p>今天到网上查找相关资料，才补上了这个基础的知识：</p><p>中间元素的选取可以使用如下公式：<code>mid = left + (right - left)/2;</code></p><p>这样不论当数组元素个数为偶数或者奇数的时候都可以正确选取到中间元素。</p><h3 id="二分查找的思想"><a href="#二分查找的思想" class="headerlink" title="二分查找的思想"></a>二分查找的思想</h3><p>其实二分查找是利用的算法设计思想中的 分治法，一步一步缩小查找范围，最终得到问题的解。</p><blockquote><p>分治法：将一个复杂的问题分解为多个相同或相似的子问题，再对子问题进行求解，进而得到问题的解。</p></blockquote><p>二分法的求解过程可以用二叉树来描述，对于一个有序的数组，根结点为最开始选取的中间元素，根结点的左右两个孩子分别为左数组的中间节点及右数组的中间节点，孩子的孩子同理；</p><p>所以通过查找树（判定树）可以看出查找的元素要经过几次比较以及跟哪些元素进行了比较。</p><h3 id="二分查找的时间复杂度"><a href="#二分查找的时间复杂度" class="headerlink" title="二分查找的时间复杂度"></a>二分查找的时间复杂度</h3><p>O(log2n)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于二分查找（折半查找）的即记录&quot;&gt;&lt;a href=&quot;#关于二分查找（折半查找）的即记录&quot; class=&quot;headerlink&quot; title=&quot;关于二分查找（折半查找）的即记录&quot;&gt;&lt;/a&gt;关于二分查找（折半查找）的即记录&lt;/h2&gt;&lt;p&gt;之前其实也学习过二分查找的理
      
    
    </summary>
    
    
  </entry>
  
</feed>
