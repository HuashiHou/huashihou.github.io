<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wayne&#39;s blog</title>
  
  <subtitle>一个有情调的程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-27T15:13:32.322Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>侯骅十</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单链表之查找单链表的中间节点</title>
    <link href="http://yoursite.com/posts/29610/"/>
    <id>http://yoursite.com/posts/29610/</id>
    <published>2019-07-28T04:14:59.000Z</published>
    <updated>2019-07-27T15:13:32.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表之查找单链表的中间节点"><a href="#单链表之查找单链表的中间节点" class="headerlink" title="单链表之查找单链表的中间节点"></a>单链表之查找单链表的中间节点</h1><p>这个实际上之前在反转算法中已经实现过了，这里给大家复习以下思路。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用快指针和慢指针的方法，快指针每次走两步，慢指针每次走一步，当快指针到达尾部的时候，慢指针刚好走过了链表长度的1/2 即指向了中间节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表节点个数为奇数时返回中间节点</span></span><br><span class="line"><span class="comment"> * 为偶数时返回靠右的中间节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findMiddleNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode pSlow = head, pFast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (pFast != <span class="keyword">null</span> &amp;&amp; pFast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pFast = pFast.next.next;</span><br><span class="line">        pSlow = pSlow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pFast == null时为链表个数奇数个，否则为偶数个（取决于快指针最开始从哪里起始）</span></span><br><span class="line">    <span class="keyword">return</span> pFast==<span class="keyword">null</span>? pSlow:pSlow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里会涉及到链表长度是偶数还是奇数的问题，可以看return语句中的三目运算，理解了之后就可以根据自己的需求灵活调整。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单链表之查找单链表的中间节点&quot;&gt;&lt;a href=&quot;#单链表之查找单链表的中间节点&quot; class=&quot;headerlink&quot; title=&quot;单链表之查找单链表的中间节点&quot;&gt;&lt;/a&gt;单链表之查找单链表的中间节点&lt;/h1&gt;&lt;p&gt;这个实际上之前在反转算法中已经实现过了，这里
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单链表之合并两个有序单链表</title>
    <link href="http://yoursite.com/posts/30700/"/>
    <id>http://yoursite.com/posts/30700/</id>
    <published>2019-07-27T14:14:42.000Z</published>
    <updated>2019-07-27T15:10:03.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表之合并两个有序单链表"><a href="#单链表之合并两个有序单链表" class="headerlink" title="单链表之合并两个有序单链表"></a>单链表之合并两个有序单链表</h1><p>题目说的是：合并两个有序的单链表，两个链表既然都有序，那其实我们要做的工作就不是很多了，如果两个链表是无序的，那我们还需要各自对两个链表进行排序再进行合并的操作。</p><h2 id="思路一：遍历实现"><a href="#思路一：遍历实现" class="headerlink" title="思路一：遍历实现"></a>思路一：遍历实现</h2><p>这种实现方式思路比较清晰，代码也比较容易理解，但是较为冗长，我自己没有进行实现，大家可以<a href="https://blog.csdn.net/zm13007310400/article/details/78317821" target="_blank" rel="noopener">点击链接</a>去作者的博客了解一下。</p><h2 id="思路二：递归实现"><a href="#思路二：递归实现" class="headerlink" title="思路二：递归实现"></a>思路二：递归实现</h2><p>不得不说递归的实现方法真的太巧妙了， 几行代码解决问题。递归比较考验我们的抽象问题的能力。</p><blockquote><p>关于递归，有以下几个要点：1. 问题可以分解为多个相同的小问题。2. 每个小问题的处理方式一样的。</p><p>比如我们在电影院，想自己在第几排，那我们可以问前一排的人他在第几排，我们+1就可以了，但是他也不知道在第几排，所以他又去问他前面的人，这样一个接一个问到第一排的人，再一个个返回来。就知道自己第几排了。这就是递归的思路。</p></blockquote><p>合并两个单链表，无非就是不断比较他们当前的节点，将大的（或小的）一个，链接到新的链表上。这里很好的运用了递归把大问题化解成N个小的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归从开始比较两个链表，放入新的链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeTwoLinkedList</span><span class="params">(ListNode h1, ListNode h2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这两个属于递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> h2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> h1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (h1.val &lt;= h2.val) &#123;</span><br><span class="line">        head = h1;</span><br><span class="line">        head.next(mergeTwoLinkedList(h1.next, h2));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        head = h2;</span><br><span class="line">        head.next(mergeTwoLinkedList(h1, h2.next));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>算法专栏的王争老师在递归这节课中有一句话说的很好：不要试图去详细分析递归的运行过程。 研究过递归代码的同学应该都深有体会，稍稍复杂一点，就很容易看晕，放心，这不是因为我们脑容量不够或者比较笨！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单链表之合并两个有序单链表&quot;&gt;&lt;a href=&quot;#单链表之合并两个有序单链表&quot; class=&quot;headerlink&quot; title=&quot;单链表之合并两个有序单链表&quot;&gt;&lt;/a&gt;单链表之合并两个有序单链表&lt;/h1&gt;&lt;p&gt;题目说的是：合并两个有序的单链表，两个链表既然都有序
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单链表之删除链表中倒数第n个节点</title>
    <link href="http://yoursite.com/posts/53885/"/>
    <id>http://yoursite.com/posts/53885/</id>
    <published>2019-07-27T14:14:26.000Z</published>
    <updated>2019-07-27T14:27:47.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表之删除链表中倒数第n个节点"><a href="#单链表之删除链表中倒数第n个节点" class="headerlink" title="单链表之删除链表中倒数第n个节点"></a>单链表之删除链表中倒数第n个节点</h1><p>这篇依然是学习专栏《数据结构与算法之美》链表相关内容的拓展。</p><p>删除链表中倒数第n个节点其实有几种不同的思路，</p><ul><li>可以先遍历一遍记下每个节点的位置，最后再遍历找到倒数第n个节点进行删除</li></ul><p>学习过时间复杂度分析的同学应该就会发现，这里要遍历两次，在最坏的情况下（要删除的是倒数第一个节点），那么消耗的时间就可以达到2T(n).</p><ul><li>使用快慢指针，快指针指向慢指针后的n个节点，然后快慢指针同时前进，直到快指针达到尾部，此时慢指针指向的next就是我们要删除的节点了。</li></ul><p>这种方法我刚看到的时候就觉得挺巧妙的，实现也比较简单，下面附上这种解法的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用快慢指针，快指针比慢指针多n</span></span><br><span class="line"><span class="comment">     * 所以当快指针抵达尾部，满指针的next就是准备删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteNodeFromBack</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空链表</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode pSlow = head;</span><br><span class="line">        ListNode pFast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pFast = pFast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pFast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pFast = pFast.next;</span><br><span class="line">            pSlow = pSlow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        pSlow.next = pSlow.next.next;</span><br><span class="line"><span class="comment">//        System.out.println(pSlow);</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：这里我有些极限情况是没有处理到的，比如n大于了整个链表的长度，为了简洁明了向大家展示这个算法的思路。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单链表之删除链表中倒数第n个节点&quot;&gt;&lt;a href=&quot;#单链表之删除链表中倒数第n个节点&quot; class=&quot;headerlink&quot; title=&quot;单链表之删除链表中倒数第n个节点&quot;&gt;&lt;/a&gt;单链表之删除链表中倒数第n个节点&lt;/h1&gt;&lt;p&gt;这篇依然是学习专栏《数据结构
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单链表之判断表中是否存在环</title>
    <link href="http://yoursite.com/posts/11578/"/>
    <id>http://yoursite.com/posts/11578/</id>
    <published>2019-07-27T14:13:58.000Z</published>
    <updated>2019-07-27T14:52:12.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表之判断表中是否存在环"><a href="#单链表之判断表中是否存在环" class="headerlink" title="单链表之判断表中是否存在环"></a>单链表之判断表中是否存在环</h1><p>这篇依然是学习专栏《数据结构与算法之美》的拓展练习。<br>链表中的环其实是一个挺有趣的问题，如果链表中存在环，对其进行遍历的时候就会发现next永远存在节点，循环往复永远不会终止。所以我们在遍历链表之前还是判断链表中是否存在环安全一点。</p><p>这篇文章不止讲解了如何判断链表中是否存在环，还贴出了链表中非环部分的长度、环的长度、环的起始点这些算法。</p><h2 id="判断链表中是否存在环"><a href="#判断链表中是否存在环" class="headerlink" title="判断链表中是否存在环"></a>判断链表中是否存在环</h2><h3 id="方法一：使用快慢节点"><a href="#方法一：使用快慢节点" class="headerlink" title="方法一：使用快慢节点"></a>方法一：使用快慢节点</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>学习过其他链表算法的同学应该对快慢指针方法很熟悉了，这里也是使用快慢指针的方法。</p><p>原理就是，快指针既然走的比慢指针快，那么当链表中存在环的时候，快慢指针必定在一个位置会相遇，也就是pFast=pSlow。当这个条件一成立我们即可以断定这个链表存在环。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用快慢指针，</span></span><br><span class="line"><span class="comment">     * 快指针每次走两步，慢指针每次走一步</span></span><br><span class="line"><span class="comment">     * 如果链表中有环，那两个指针必定有相遇的时候</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doesLinkedListHasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode pFast = head.next.next,pSlow = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pFast.next != <span class="keyword">null</span> &amp;&amp; pSlow.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pFast == pSlow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pFast = pFast.next.next;</span><br><span class="line">            pSlow = pSlow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：使用Map将节点作为key"><a href="#方法二：使用Map将节点作为key" class="headerlink" title="方法二：使用Map将节点作为key"></a>方法二：使用Map将节点作为key</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这里就是利用的Map的key唯一的特性，遍历链表，当发现map中已经存在当前遍历到的节点时，即我们是再一次来到了这个节点，证明链表存在环。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Map将每一个走过的节点存进去</span></span><br><span class="line"><span class="comment"> * 在存之前get一下，如果get有值，说明之前存过，即证明有环</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doesLinkedListHasCycle1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ListNode, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    ListNode p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(p)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(p, <span class="keyword">null</span>);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找环的起点"><a href="#查找环的起点" class="headerlink" title="查找环的起点"></a>查找环的起点</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>查找环的起点的前提就是链表要存在环，所以此算法的前半部分就是利用了前面的快慢指针判断法，不同的是，当确定存在环的时候我们即跳出循环。</p><p>这里有一个推导过程，我参考别人的博客。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/hexo_blog/20190726/01.png" alt="推导过程" title>                </div>                <div class="image-caption">推导过程</div>            </figure><blockquote><p>参考：<a href="https://blog.csdn.net/jiaobuchong/article/details/84727007" target="_blank" rel="noopener">https://blog.csdn.net/jiaobuchong/article/details/84727007</a></p></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>看懂了上面的推导过程，我们直接按照其实现对应的代码就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找链表环的起点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null代表没有环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findCycleHead</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode pFast = head, pSlow = head;</span><br><span class="line">    <span class="comment">// 循环直到快慢指针相遇</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        pFast = pFast.next.next;</span><br><span class="line">        pSlow = pSlow.next;</span><br><span class="line">        <span class="keyword">if</span> (pFast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pFast == pSlow) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让快指针等于头节点，然后各自以1 的步长继续前进，直到再次相遇</span></span><br><span class="line">    <span class="comment">// 相遇点即为环的起始点</span></span><br><span class="line">    pFast = head;</span><br><span class="line">    <span class="comment">// 可以顺便计算出非环部分的长度</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        pFast = pFast.next;</span><br><span class="line">        pSlow = pSlow.next;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (pFast == pSlow) &#123;</span><br><span class="line">            System.out.println(<span class="string">"length of not cycle in this LinkedList: "</span> + i);</span><br><span class="line">            <span class="keyword">return</span> pFast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算环的长度"><a href="#计算环的长度" class="headerlink" title="计算环的长度"></a>计算环的长度</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这个算法依然用到了快慢指针，类比到生活中就像是两个人在操场跑步，一个人跑的快一个人跑的慢一点。</p><p>我们现在假设快指针叫快男，慢指针叫慢哥</p><p>在计算环长度这个算法中，快男和慢男同时在起点起跑，当快男第一次追上慢哥时（即快男已经领先一圈，假设这里时位置a），这是慢哥停下站在原地不动，快男继续跑，当快男再一次追上慢哥的时候（快男转了一圈回到位置a），所以刚刚快男走过的长度就是环的长度。类比到代码里应该就很好理解了。</p><blockquote><p>要注意的是极端条件的处理，防止异常情况的发生，让代码尽可能的健壮</p></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算环的长度，没有环就返回0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCycleLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pFast = head, pSlow = head;</span><br><span class="line">    <span class="comment">// 直到相遇</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        pFast = pFast.next.next;</span><br><span class="line">        pSlow = pSlow.next;</span><br><span class="line">        <span class="keyword">if</span> (pFast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pFast == pSlow) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pFast停下，pSlow继续走，直到再次相遇 pSlow走过的长度即为环的长度</span></span><br><span class="line">    <span class="keyword">int</span> cycleLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        pSlow = pSlow.next;</span><br><span class="line">        cycleLength++;</span><br><span class="line">        <span class="keyword">if</span> (pSlow == pFast) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cycleLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单链表之判断表中是否存在环&quot;&gt;&lt;a href=&quot;#单链表之判断表中是否存在环&quot; class=&quot;headerlink&quot; title=&quot;单链表之判断表中是否存在环&quot;&gt;&lt;/a&gt;单链表之判断表中是否存在环&lt;/h1&gt;&lt;p&gt;这篇依然是学习专栏《数据结构与算法之美》的拓展练习。
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单链表之：反转算法</title>
    <link href="http://yoursite.com/posts/55684/"/>
    <id>http://yoursite.com/posts/55684/</id>
    <published>2019-07-20T07:13:12.000Z</published>
    <updated>2019-07-20T07:51:45.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表之：链表反转算法"><a href="#单链表之：链表反转算法" class="headerlink" title="单链表之：链表反转算法"></a>单链表之：链表反转算法</h1><p>上一篇博客讲述了一些链表的知识以及判断是否为回文串的算法，详见<a href="/posts/64872/">如何判断一个单链表是否为回文串？</a></p><h2 id="一、递归方法"><a href="#一、递归方法" class="headerlink" title="一、递归方法"></a>一、递归方法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从头节点开始，递归调用头节点的next，实际上就是从尾节点一次反转各个节点的指针指向。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160411103016811?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="来源：见参考" title>                </div>                <div class="image-caption">来源：见参考</div>            </figure><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种，递归 在反转当前节点之前先反转后续节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ListNode <span class="title">reverse0</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head ==<span class="keyword">null</span> || head.next ==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归 从最后一个节点开始反转</span></span><br><span class="line">        ListNode reHead = reverse0(head.next);</span><br><span class="line">        head.next.next = head;<span class="comment">// 自己的下一个的下一个指向自己就是反转过来了</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;<span class="comment">// 清空自己的next指针 相当于断开链表</span></span><br><span class="line">        <span class="keyword">return</span> reHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二、非递归方法"><a href="#二、非递归方法" class="headerlink" title="二、非递归方法"></a>二、非递归方法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>从前到后，每两个节点依次进行反转。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20160411103425114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="来源见参考" title>                </div>                <div class="image-caption">来源见参考</div>            </figure><h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不使用递归的方法，从前向后进行两两进行交换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ListNode <span class="title">reverse1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode prev = head;<span class="comment">// 代表前一个节点</span></span><br><span class="line">    ListNode cur = head.next;<span class="comment">// 代表当前节点</span></span><br><span class="line">    ListNode temp = <span class="keyword">null</span>;<span class="comment">// 代表下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        temp = cur.next;<span class="comment">// 暂存下一个节点，后面赋值回来</span></span><br><span class="line">        cur.next = prev;<span class="comment">// 最关键的一句，当前节点next指向前一个节点，即反转了方向</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针 整体向后移，当前节点变成前节点，下一节点变成当前节点</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListNode"><a href="#ListNode" class="headerlink" title="ListNode"></a>ListNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// builder mode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">next</span><span class="params">(ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">", next="</span> + next +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="string">'a'</span>);</span><br><span class="line">        head.next(<span class="keyword">new</span> ListNode(<span class="string">'b'</span>)).next(<span class="keyword">new</span> ListNode(<span class="string">'d'</span>));</span><br><span class="line"><span class="comment">//        System.out.println(reverse0(head));</span></span><br><span class="line">        System.out.println(reverse1(head));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://blog.csdn.net/guyuealian/article/details/51119499#commentsedit" target="_blank" rel="noopener">https://blog.csdn.net/guyuealian/article/details/51119499#commentsedit</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单链表之：链表反转算法&quot;&gt;&lt;a href=&quot;#单链表之：链表反转算法&quot; class=&quot;headerlink&quot; title=&quot;单链表之：链表反转算法&quot;&gt;&lt;/a&gt;单链表之：链表反转算法&lt;/h1&gt;&lt;p&gt;上一篇博客讲述了一些链表的知识以及判断是否为回文串的算法，详见&lt;a 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>专栏学习笔记：为什么很多编程语言中数组都从0开始编号？</title>
    <link href="http://yoursite.com/posts/7261/"/>
    <id>http://yoursite.com/posts/7261/</id>
    <published>2019-07-20T03:14:32.000Z</published>
    <updated>2019-07-20T03:44:49.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="专栏学习笔记：为什么很多编程语言中数组都从0开始编号？"><a href="#专栏学习笔记：为什么很多编程语言中数组都从0开始编号？" class="headerlink" title="专栏学习笔记：为什么很多编程语言中数组都从0开始编号？"></a>专栏学习笔记：为什么很多编程语言中数组都从0开始编号？</h1><h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>除了数组，链表、队列、栈等也是线性表结构。</p><h3 id="非线性表"><a href="#非线性表" class="headerlink" title="非线性表"></a>非线性表</h3><p>二叉树、堆、图等都是非线性表，之所以叫非先行是因为 数据在非线性表中并不是简单的前后关系。</p><h2 id="数组越界问题在java和c中的差别"><a href="#数组越界问题在java和c中的差别" class="headerlink" title="数组越界问题在java和c中的差别"></a>数组越界问题在java和c中的差别</h2><p>由于在c语言中，只要不是受限的内存，所有的内存空间都可以是自由访问的。所以当C语言中数组的下标超过了数组的长度，并不会直接出错，而是会出现其他奇怪的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这段C代码，由于循环条件写成了&lt;=3所以 在执行3次以后，数组下标访问越界，这个会造成死循环一致输出hello world问题，这里由于涉及到其他方面的原理，暂不深究，这里贴出作者的讲解和其他读者的评论给大家参考。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/hexo_blog/20190720/02.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/hexo_blog/20190720/03.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/hexo_blog/20190720/04.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>而在java中的话，虚拟机就会抛出数组越界异常。</p><h2 id="高级语言中的容器"><a href="#高级语言中的容器" class="headerlink" title="高级语言中的容器"></a>高级语言中的容器</h2><p>以java为例，作为java程序员可能每天都在使用的ArrayList，就是对数组进行一定程度的封装，比如自动扩容，迭代器等 方便程序员的使用。</p><h2 id="容器与数组的选择"><a href="#容器与数组的选择" class="headerlink" title="容器与数组的选择"></a>容器与数组的选择</h2><p>既然容器这么好用，那数组是不是就全无用武之地了呢？</p><p>当然不是，有些时候，使用数组会更加合适。下面列出的几种常见的情况：</p><ol><li><p>由于java的ArrayList只能存储Integer、Float等包装类型，不能存储基本类型， 在自动拆箱装箱会有一定的性能消耗。</p></li><li><p>如果事先已知数据的大小，那么使用数组会更加方便，在声明数组的时候直接指定好它的大小。研究过ArrayList源代码的同学应该知道，ArraylList底层也是数组，如果不指定初始长度的话，每一次快满了的时候都会自动扩容，而扩容就是使用了数组复制，想象一下，如果你的List有1G的数据，容器扩容到1.5G，就要把这1G的数据复制过去，是不是想想都很费时间。当然，使用ArrayList也可以事先指定好一个大小。关于这一块的源码分析可以看别人的另外一篇文章：<a href="https://blog.csdn.net/fighterandknight/article/details/61240861" target="_blank" rel="noopener">https://blog.csdn.net/fighterandknight/article/details/61240861</a> </p></li></ol><h2 id="为什么数组从0开始编号"><a href="#为什么数组从0开始编号" class="headerlink" title="为什么数组从0开始编号"></a>为什么数组从0开始编号</h2><p>从存储模型的角度来看，数组的下标说是偏移量更为准确，它的英文offset也正是此意。偏移量就表示了相对于首地址偏移了多少，学过C语言的同学应该记得，如果把数组赋给一个变量， 那它的指针就是指向数组的头节点，而头节点的偏移量就是0。是不是很好理解了？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;专栏学习笔记：为什么很多编程语言中数组都从0开始编号？&quot;&gt;&lt;a href=&quot;#专栏学习笔记：为什么很多编程语言中数组都从0开始编号？&quot; class=&quot;headerlink&quot; title=&quot;专栏学习笔记：为什么很多编程语言中数组都从0开始编号？&quot;&gt;&lt;/a&gt;专栏学习笔
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何判断一个单链表是否为回文串？</title>
    <link href="http://yoursite.com/posts/64872/"/>
    <id>http://yoursite.com/posts/64872/</id>
    <published>2019-07-20T02:58:10.000Z</published>
    <updated>2019-07-20T02:59:10.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何判断一个单链表是否为回文串？"><a href="#如何判断一个单链表是否为回文串？" class="headerlink" title="如何判断一个单链表是否为回文串？"></a>如何判断一个单链表是否为回文串？</h1><h2 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h2><p>这道题是极客时间专栏数据结构与算法之美《06 | 链表（上）：如何实现LRU缓存淘汰算法?》里面的一道思考题，同时也是leetcode上的一道题目，原题为：<a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-linked-list/</a></p><p>由于我在算法方面的基础比较薄弱，所以直接去看了别人的解决方法，也花了好一会才看懂，加上照着敲一遍代码，跑debug 最终才完全理解了这种解法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>里面的注释都是我在思考过后补充上去的，相信大家理解了之后再删掉注释也会感觉豁然开朗。</p><ul><li><p>我自己给ListNode使用了builder模式，方便测试的时候输入数据（其实不算是严格的builder模式，真正的builder是返回对象this，这里是返回了next的引用）</p></li><li><p>我的注释可能影响你的思考，可以尝试忽略我的注释或者删掉，自己思考</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a singly linked list, determine if it is a palindrome.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromeLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// solution</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次跳两个 变相控制了循环的次数，相当于除2</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">// 临时变量 暂存</span></span><br><span class="line">            ListNode next = slow.next;</span><br><span class="line">            <span class="comment">// 一开始prev为空时：slow变成了头节点；到后面就是把本来在prev的元素变成它的next</span></span><br><span class="line">            slow.next = prev;</span><br><span class="line">            prev = slow;</span><br><span class="line"></span><br><span class="line">            slow = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束 prev就是链表前半部分反序后的链表，slow就是原链表的后半部分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链表节点为偶数时刚好除尽，为奇数时这里的fast就是最后一个节点</span></span><br><span class="line">        <span class="comment">// 节点个数为奇数时则不用比较中间节点 所以这里.next跳过了中间节点</span></span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次比较，如果有不同直接返回false</span></span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slow.val != prev.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="string">'a'</span>);</span><br><span class="line">        head.next(<span class="keyword">new</span> ListNode(<span class="string">'b'</span>)).next(<span class="keyword">new</span> ListNode(<span class="string">'a'</span>));</span><br><span class="line">        System.out.println(head);</span><br><span class="line">        System.out.println(isPalindrome(head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// builder mode</span></span><br><span class="line">    <span class="function">ListNode <span class="title">next</span><span class="params">(ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;"</span> +</span><br><span class="line">                <span class="string">"val="</span> + val +</span><br><span class="line">                <span class="string">", next="</span> + next +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/hexo_blog/20190720/WX20190720-104751%402x.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何判断一个单链表是否为回文串？&quot;&gt;&lt;a href=&quot;#如何判断一个单链表是否为回文串？&quot; class=&quot;headerlink&quot; title=&quot;如何判断一个单链表是否为回文串？&quot;&gt;&lt;/a&gt;如何判断一个单链表是否为回文串？&lt;/h1&gt;&lt;h2 id=&quot;前情&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Tomcat之一：Tomcat基础架构</title>
    <link href="http://yoursite.com/posts/24480/"/>
    <id>http://yoursite.com/posts/24480/</id>
    <published>2019-07-06T09:26:18.000Z</published>
    <updated>2019-07-06T09:00:30.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Tomcat之一：Tomcat基础架构"><a href="#深入理解Tomcat之一：Tomcat基础架构" class="headerlink" title="深入理解Tomcat之一：Tomcat基础架构"></a>深入理解Tomcat之一：Tomcat基础架构</h1><h2 id="Tomcat的定义（来自wiki百科）"><a href="#Tomcat的定义（来自wiki百科）" class="headerlink" title="Tomcat的定义（来自wiki百科）"></a>Tomcat的定义（来自wiki百科）</h2><p>Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个<strong>Servlet容器</strong>，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如**Tomcat管理和控制平台、安全域管理和Tomcat阀等。</p><p>由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。</p><h2 id="Http服务器与应用服务器"><a href="#Http服务器与应用服务器" class="headerlink" title="Http服务器与应用服务器"></a>Http服务器与应用服务器</h2><p>之前在技术讨论群里看到一个群友提问：nginx和tomcat有什么区别呀？其实提出这种问题就可以得知他对两个服务器的基础概念都还不是很清晰。 严格来讲，Nginx、Apache这些叫做Http Server； 而Tomcat是Application Server，更准确的说，是一个Servlet、Jsp容器。 一个 <strong>HTTP Server 关心的是 HTTP 协议层面的传输和访问控制</strong>，所以在 Apache/Nginx 上你可以看到<strong>代理、负载均衡</strong>等功能。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。一个 HTTP Server 始终只是把服务器上的文件如实的通过 HTTP 协议传输给客户端。 对于 Tomcat 来说，就是需要<strong>提供 JSP/Sevlet 运行需要的标准类库、Interface 等</strong>。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。 回到上面的问题，在我的理解看来，Nginx更像一个协调管理者的角色，而Tomcat用“容器”这个词语形容它会更加形象贴切一点。</p><h2 id="Tomcat的整体架构"><a href="#Tomcat的整体架构" class="headerlink" title="Tomcat的整体架构"></a>Tomcat的整体架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images-cdn.shimo.im/HXQSiPn6iJ0hiTzk/image.png!original" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Tomcat最顶层的容器是Server， 代表整个服务器，从上图可以看出一个 Server至少包含 一个Service，用于具体提供服务。</p><h3 id="两个主要组件"><a href="#两个主要组件" class="headerlink" title="两个主要组件"></a>两个主要组件</h3><h4 id="Connecter"><a href="#Connecter" class="headerlink" title="Connecter"></a>Connecter</h4><p>用于<strong>处理连接相关</strong>的事，并提供<strong>Socket</strong>与Request和Response相关的转化;</p><h5 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h5><p>一个Connecter将在某个指定的<strong>端口上侦听客户请求，接收浏览器的发过来的 tcp 连接请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据</strong>，然后会产生一个线程来处理这个请求并把产生的 Request 和 Response 对象传给处理Engine(Container中的一部分)，从Engine出获得响应并返回客户。 Tomcat中有两个经典的Connector，</p><ul><li><p>一个直接侦听来自Browser的HTTP请求，</p></li><li><p>另外一个来自其他的WebServer请求。</p></li></ul><p>HTTP/1.1 Connector在端口8080处侦听来自客户Browser的HTTP请求，AJP/1.3 Connector在端口8009处侦听其他Web Server（其他的HTTP服务器）的Servlet/JSP请求。</p><p>Connector 最重要的功能就是接收连接请求然后分配线程让 Container 来处理这个请求，所以这必然是多线程的，多线程的处理是 Connector 设计的核心。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images-cdn.shimo.im/HF9ScgG4RrsO003A/image.png!thumbnail" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Connector 中具体是用<strong>ProtocolHandler</strong> 来处理请求的，不同的ProtocolHandler 代表不同的连接类型，比如， Http11Protocol 使用的是普通Socket 来连接的， Http 11 NioProtocol 使用的是NioSocket 来连接的。</p><p>ProtocolHandler 里面有3 个非常重要的组件： Endpoint 、Processor 和Adapter。</p><ul><li><p><strong>Endpoint</strong>用于处理底层Socket 的网络连接，</p><ul><li><p><strong>Acceptor</strong> 用于监昕请求</p></li><li><p><strong>AsyncTimeout</strong> 用于检查异步request 的超时</p></li><li><p><strong>Handler</strong> 用于处理接收到的Socket，在内部调用了Processor 进行处理。</p></li></ul></li><li><p><strong>Processor</strong> 用于将Endpoint 接收到的Socket 封装成Request,</p></li><li><p><strong>Adapter</strong> 用于将封装好的Request 交给Container 进行具体处理。</p></li></ul><p><strong><em>也就是说Endpoint用来实现TCP/IP 协议， Processor 用来实现HTTP 协议， Adapter 将请求适配到Servlet 容器进行具体处理。</em></strong></p><h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4><p>用于<strong>封装和管理Servlet</strong>，以及具体<strong>处理Request请求</strong>；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images-cdn.shimo.im/pZ1MD2LFC1ojN7Fa/image.png!thumbnail" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器。</p><p>4个子容器的作用分别是：</p><p>（1）Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；</p><p>（2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；</p><p>（3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；</p><p>（4）Wrapper：每一Wrapper封装着一个Servlet；</p><h3 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h3><ul><li><p><strong>Jasper</strong>：负责jsp页面的解析，jsp属性的验证,同时负责将jsp动态转换为java代码并编译成class。</p></li><li><p><strong>Naming</strong>：资源管理，负责数据库连接池、EJB、mail等通过JDNI获取的内容。</p></li><li><p><strong>Session</strong>：会话管理的组件</p></li><li><p><strong>Logging</strong>：日志相关</p></li><li><p><strong>JMX</strong>：性能监控等</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解Tomcat之一：Tomcat基础架构&quot;&gt;&lt;a href=&quot;#深入理解Tomcat之一：Tomcat基础架构&quot; class=&quot;headerlink&quot; title=&quot;深入理解Tomcat之一：Tomcat基础架构&quot;&gt;&lt;/a&gt;深入理解Tomcat之一：Tomc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解Tomcat之二：自己动手实现一个简单的Tomcat</title>
    <link href="http://yoursite.com/posts/6083/"/>
    <id>http://yoursite.com/posts/6083/</id>
    <published>2019-07-06T09:26:18.000Z</published>
    <updated>2019-07-06T09:00:30.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Tomcat之二：自己动手实现一个简单的Tomcat"><a href="#深入理解Tomcat之二：自己动手实现一个简单的Tomcat" class="headerlink" title="深入理解Tomcat之二：自己动手实现一个简单的Tomcat"></a>深入理解Tomcat之二：自己动手实现一个简单的Tomcat</h1><p>学习一个新的知识的过程就是 看别人的文章、听别人讲、自己查资料、自己给别人讲。我们对于新知识的认识成都以及理解深度都是在整个过程中不断的加深的。所以我一直提倡大家要乐于分享，当你给别人用组织系统化的语言或者文章将你头脑中的知识输出来，你就会发现，你对之前知识的理解又加深了一个程度。 而这一篇手写tomcat，其实也是我在学习tomcat架构的过程中，模仿别人的代码自己再手敲一遍，最后将思路和实现过程整理成文，输出给大家。</p><h2 id="主要需求"><a href="#主要需求" class="headerlink" title="主要需求"></a>主要需求</h2><ul><li><p>监听请求端口</p></li><li><p>封装请求和返回</p></li><li><p>对请求进行处理</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/19070601.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上面就是mini tomcat的类图</p><h2 id="各个类"><a href="#各个类" class="headerlink" title="各个类"></a>各个类</h2><h3 id="MyRequest"><a href="#MyRequest" class="headerlink" title="MyRequest"></a>MyRequest</h3><pre><code>自己封装的请求类，相当于servlet中的HttpRequest。</code></pre><ul><li><p>inputStream来自于socket的输入流，用浏览器访问的时候就会包含了整个请求的报文</p></li><li><p>解析http请求头的第一行 拿出协议中的 GET 或者 POST 还有请求url</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己封装的请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRequest</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String httpRequest = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] requestBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> length = inputStream.read(requestBytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            httpRequest = <span class="keyword">new</span> String(requestBytes, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析内容</span></span><br><span class="line">        <span class="comment">// 第一行是http头部内容</span></span><br><span class="line">        String httpHead = httpRequest.split(<span class="string">"\n"</span>)[<span class="number">0</span>];</span><br><span class="line">        url = httpHead.split(<span class="string">"\\s"</span>)[<span class="number">1</span>];</span><br><span class="line">        method = httpHead.split(<span class="string">"\\s"</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"接收到请求-------》"</span>);</span><br><span class="line">        System.out.println(<span class="string">"请求信息 ："</span> + toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"url: "</span> + url + <span class="string">", method: "</span> + method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyResponse"><a href="#MyResponse" class="headerlink" title="MyResponse"></a>MyResponse</h3><ul><li>要点在于手动按照http协议的格式进行响应，这样浏览器才可以识别</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己封装的响应</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResponse</span><span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputStream = outputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String content)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outputStream!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            StringBuffer httpResponse = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照http响应格式输出</span></span><br><span class="line">            httpResponse.append(<span class="string">"HTTP/1.1 200 OK\n"</span>)</span><br><span class="line">                    .append(<span class="string">"Content-Type: text/html\n"</span>)</span><br><span class="line">                    .append(<span class="string">"\r\n"</span>)</span><br><span class="line">                    .append(<span class="string">"&lt;html&gt;&lt;body&gt;"</span>)</span><br><span class="line">                    .append(content)</span><br><span class="line">                    .append(<span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"返回信息："</span>+httpResponse.toString());</span><br><span class="line"></span><br><span class="line">            outputStream.write(httpResponse.toString().getBytes());</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyServlet"><a href="#MyServlet" class="headerlink" title="MyServlet"></a>MyServlet</h3><p>抽象的Servlet，可以继承它来有很多不同的实现。</p><ul><li>service 方法根据请求的方法分发到get或者post进行处理，这里与</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己封装的Servlet</span></span><br><span class="line"><span class="comment"> * 继承后做不同的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(MyRequest httpRequest, MyResponse httpResponse)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(MyRequest httpRequest, MyResponse httpResponse)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(MyRequest request, MyResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"POST"</span>.equalsIgnoreCase(request.getMethod())) &#123;</span><br><span class="line">                doPost(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"GET"</span>.equalsIgnoreCase(request.getMethod())) &#123;</span><br><span class="line">                doGet(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HelloServlet"><a href="#HelloServlet" class="headerlink" title="HelloServlet"></a>HelloServlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet的实现类，在post get中添加具体的业务逻辑</span></span><br><span class="line"><span class="comment"> * 以前使用servlet编程的时候也是这样的实现方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">MyServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(MyRequest httpRequest, MyResponse httpResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            httpResponse.write(<span class="string">"get method in hello servlet !!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(MyRequest httpRequest, MyResponse httpResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            httpResponse.write(<span class="string">"post method in hello servlet"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServletMapping"><a href="#ServletMapping" class="headerlink" title="ServletMapping"></a>ServletMapping</h3><p>其实是一个Bean，简单封装了配置信息，方便我们读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String servletName;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String clazz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServletMapping</span><span class="params">(String servletName, String url, String clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servletName = servletName;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> servletName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServletName</span><span class="params">(String servletName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servletName = servletName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClazz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClazz</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServletMappingConfig"><a href="#ServletMappingConfig" class="headerlink" title="ServletMappingConfig"></a>ServletMappingConfig</h3><p>存着一个列表来保存配置，真正tomcat也不是这样实现的。我们只是为了效果方便实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里由于是demo 采用简洁的方式先进行配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletMappingConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;ServletMapping&gt; config = <span class="keyword">new</span> ArrayList&lt;ServletMapping&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在真正的tomcat中是扫描web.xml的配置来初始化ServletMapping</span></span><br><span class="line">   <span class="keyword">static</span>  &#123;</span><br><span class="line">        config.add(<span class="keyword">new</span> ServletMapping(<span class="string">"hello"</span>, <span class="string">"/hello"</span>, <span class="string">"com.practice.HelloServlet"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyTomcat"><a href="#MyTomcat" class="headerlink" title="MyTomcat"></a>MyTomcat</h3><p>minitomcat的核心类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTomcat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; mapping = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTomcat</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用socket不断等候接收新的请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initservletMappings();</span><br><span class="line"></span><br><span class="line">        ServerSocket socket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"Tomcat 启动成功～～"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket accept = socket.accept();</span><br><span class="line">                InputStream inputStream = accept.getInputStream();</span><br><span class="line">                OutputStream outputStream = accept.getOutputStream();</span><br><span class="line"></span><br><span class="line">                MyRequest myRequest = <span class="keyword">new</span> MyRequest(inputStream);</span><br><span class="line">                MyResponse myResponse = <span class="keyword">new</span> MyResponse(outputStream);</span><br><span class="line"></span><br><span class="line">                dispatch(myRequest, myResponse);</span><br><span class="line"></span><br><span class="line"><span class="comment">//                socket.close();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置文件初始化servletMapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initservletMappings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ServletMapping servletMapping : ServletMappingConfig.config) &#123;</span><br><span class="line">            mapping.put(servletMapping.getUrl(), servletMapping.getClazz());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置找到对应的Servlet类，使用反射创建实例处理请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(MyRequest request, MyResponse response)</span> </span>&#123;</span><br><span class="line">        String url = request.getUrl();</span><br><span class="line">        String clazz = mapping.get(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clazz==<span class="keyword">null</span> || clazz==<span class="string">""</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到请求对应的链接:"</span> + url);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;MyServlet&gt; aClass = (Class&lt;MyServlet&gt;) Class.forName(clazz);</span><br><span class="line">            MyServlet myServlet = aClass.newInstance();</span><br><span class="line">            myServlet.service(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"不存在该类"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动tomcat</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyTomcat(<span class="number">8081</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们运行main方法，在浏览器中访问localhost:8081/hello 就可以看到效果啦！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-images-1251718931.cos.ap-guangzhou.myqcloud.com/2019070602.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个tomcat很mini ，只简单实现了基本的功能，大家可以在这个基础上不断添加其他的功能，让这个minitomcat越来越接近真正的tomct！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解Tomcat之二：自己动手实现一个简单的Tomcat&quot;&gt;&lt;a href=&quot;#深入理解Tomcat之二：自己动手实现一个简单的Tomcat&quot; class=&quot;headerlink&quot; title=&quot;深入理解Tomcat之二：自己动手实现一个简单的Tomcat&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring中的事件简述与Guava的EventBus</title>
    <link href="http://yoursite.com/posts/38349/"/>
    <id>http://yoursite.com/posts/38349/</id>
    <published>2019-06-11T09:26:18.000Z</published>
    <updated>2019-06-11T09:27:22.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring中的事件简述与Guava的EventBus"><a href="#Spring中的事件简述与Guava的EventBus" class="headerlink" title="Spring中的事件简述与Guava的EventBus"></a>Spring中的事件简述与Guava的EventBus</h1><h2 id="Spring的事件"><a href="#Spring的事件" class="headerlink" title="Spring的事件"></a>Spring的事件</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><ol><li><p>org.springframework.context.ApplicationEvent</p></li><li><p>org.springframework.context.ApplicationListener</p></li></ol><p>使用容器触发事件，applicationContext发布事件。</p><h3 id="简单实现逻辑"><a href="#简单实现逻辑" class="headerlink" title="简单实现逻辑"></a>简单实现逻辑</h3><ol><li><p>自定义订阅和通知事件，继承ApplicationEvent</p></li><li><p>定义事件监听器，实现ApplicationListener</p></li><li><p>使用容器发布事件（订阅、通知）</p></li></ol><h3 id="拓展-EventListener注解"><a href="#拓展-EventListener注解" class="headerlink" title="拓展@EventListener注解"></a>拓展@EventListener注解</h3><p>为了加强@EventListener的功能，Spring 4.2开始支持使用SpEL表达式定义事件触发的条件。</p><p>下面为使用了该注解的的一个实例：</p><p>Event：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isImport;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span><span class="params">(Object source, <span class="keyword">boolean</span> isImport)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.isImport = isImport;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isImport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isImport;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImport</span><span class="params">(<span class="keyword">boolean</span> anImport)</span> </span>&#123;</span><br><span class="line">        isImport = anImport;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TestEvent&#123;"</span> +</span><br><span class="line">                <span class="string">"isImport="</span> + isImport +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Listener:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当isImport为true的时候才会打印</span></span><br><span class="line">    <span class="meta">@EventListener</span>(condition=<span class="string">"#testEvent.isImport"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestEventTest</span><span class="params">(TestEvent testEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==============TestEvent=============="</span> + testEvent.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展Google-Guava中的EventBus"><a href="#拓展Google-Guava中的EventBus" class="headerlink" title="拓展Google Guava中的EventBus"></a>拓展Google Guava中的EventBus</h3><p>GoogleGuava是谷歌在日常开发过程中总结积累出来的一个类库，包含了许多常用的工具等。</p><p>Guava的优点：</p><ul><li>高效设计良好的API，被Google的开发者设计，实现和使用</li><li>遵循高效的java语法实践</li><li>使代码更刻度，简洁，简单</li><li>节约时间，资源，提高生产力</li></ul><p>Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：</p><ul><li>集合 [collections]</li><li>缓存 [caching]</li><li>原生类型支持 [primitives support]</li><li>并发库 [concurrency libraries]</li><li>通用注解 [common annotations]</li><li>字符串处理 [string processing]</li><li>I/O 等等。</li></ul><p>这里我们主要介绍Guava中的事件总线EventBus。使用Guava的事件总线就不用再像上面Spring中的继承实现接口的方法。只需要在指定的事件处理方法上加@Subscribe注解即可。</p><p>消息封装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span><span class="params">(<span class="keyword">int</span> message)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        System.out.println(<span class="string">"event message:"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息接收类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> lastMessage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(TestEvent event)</span> </span>&#123;</span><br><span class="line">        lastMessage = event.getMessage();</span><br><span class="line">        System.out.println(<span class="string">"Message:"</span>+lastMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLastMessage</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> lastMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类及输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEventBus</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReceiveEvent</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventBus eventBus = <span class="keyword">new</span> EventBus(<span class="string">"test"</span>);</span><br><span class="line">        EventListener listener = <span class="keyword">new</span> EventListener();</span><br><span class="line"></span><br><span class="line">        eventBus.register(listener);</span><br><span class="line"></span><br><span class="line">        eventBus.post(<span class="keyword">new</span> TestEvent(<span class="number">200</span>));</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> TestEvent(<span class="number">300</span>));</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> TestEvent(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">                                    System.out.println(<span class="string">"LastMessage:"</span>+listener.getLastMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出信息</span></span><br><span class="line">event message:<span class="number">200</span></span><br><span class="line">Message:<span class="number">200</span></span><br><span class="line">event message:<span class="number">300</span></span><br><span class="line">Message:<span class="number">300</span></span><br><span class="line">event message:<span class="number">400</span></span><br><span class="line">Message:<span class="number">400</span></span><br><span class="line">LastMessage:<span class="number">400</span></span><br></pre></td></tr></table></figure><p>以上即是EventBus的简单使用。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p><a href="https://shimo.im/docs/z7ggA56biOAfAdht/read" target="_blank" rel="noopener">https://shimo.im/docs/z7ggA56biOAfAdht/read</a></p><p><a href="https://www.cnblogs.com/peida/p/EventBus.html" target="_blank" rel="noopener">https://www.cnblogs.com/peida/p/EventBus.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring中的事件简述与Guava的EventBus&quot;&gt;&lt;a href=&quot;#Spring中的事件简述与Guava的EventBus&quot; class=&quot;headerlink&quot; title=&quot;Spring中的事件简述与Guava的EventBus&quot;&gt;&lt;/a&gt;Sprin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于token机制与JWT标准</title>
    <link href="http://yoursite.com/posts/33574/"/>
    <id>http://yoursite.com/posts/33574/</id>
    <published>2019-06-05T07:36:18.000Z</published>
    <updated>2019-06-05T07:49:13.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于token机制与JWT标准"><a href="#关于token机制与JWT标准" class="headerlink" title="关于token机制与JWT标准"></a>关于token机制与JWT标准</h1><p>在传统的web单体项目中，我们的会话通常使用session和cookie两样来实现。</p><h2 id="传统的cookie-session实现"><a href="#传统的cookie-session实现" class="headerlink" title="传统的cookie/session实现"></a>传统的cookie/session实现</h2><p>session是保存在服务器端的会话，使用cookie在客户端保存一个session id，每次发送请求的时候带上这个cookie服务端就可以很容易的了解当前用户是否与服务端建立了会话，以及会话是否过期等等。在单体项目中的这种实现机制相对来说是比较方便的。</p><p>使用这种机制存在的问题：</p><ol><li><p>当我们的项目变得越来越大，用户数量越来越多之后，每新建一个会话服务器就要多消耗空间来存储空间，这将使服务器内存的开销不断增加；</p></li><li><p>跨域问题，很多项目使用前后端分离开发，而且前后端也部署在不同的域，这将导致一系列跨域问题的发生；</p></li><li><p>可拓展性，只在服务器内存中存储session限制了可拓展性能；</p></li></ol><p>针对以上痛点，token机制的出现很好的解决了问题。</p><h2 id="token机制"><a href="#token机制" class="headerlink" title="token机制"></a>token机制</h2><p>使用token机制时，当用户请求时，会检查用户是否有携带token信息，或者token是否过期；未登录的话叫用户进行登录，然后服务端生成一串token返回给浏览器，可以存储在cookie或者localStorage里面。以后用户每一次发送的请求都会带上这个token。</p><p>token的组成一般是一些基础的信息，加上一个签名。这样服务器就无需存储session，每当收到一个新的请求，对token的签名进行验证，验证成功就可以进行下一步的操作。而且通常token可以存储在数据库中。</p><h2 id="JWT（Json-Web-Token）"><a href="#JWT（Json-Web-Token）" class="headerlink" title="JWT（Json Web Token）"></a>JWT（Json Web Token）</h2><p>广义上的jwt其实是token机制的一个实现标准，狭义上的jwt即是我们每次请求携带的token串。</p><p>jwt串由3部分组成，下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.</span><br><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.</span><br><span class="line">SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure><p>第一部分为header为json格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>, 加密算法类型</span><br><span class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span> token类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二部分为payload 同样为json：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;, 保留claim subject代表这个jwt的主体</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;, 自定义的claim</span><br><span class="line">  &quot;iat&quot;: 1516239022 保留claim 时间戳 代表jwt的签发时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三部分就是用header中指定的算法结合payload的内容制造出的签名。</p><blockquote><p>jwt串只是使用base64编码，并没有进行加密，所以任何人获取到jwt串都可以拿到其中传输的内容。</p></blockquote><p>当服务端获取到这一tokne之后，会有如下事件流：</p><ol><li><p>使用base64将jwt串进行还原</p></li><li><p>使用header中的算法对签名部分进行还原</p></li><li><p>对比直接从jwt中解析出的payload部分和使用算法还原的payload</p><ol><li><p>如果不一致 验证失败</p></li><li><p>一致则验证成功</p></li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>token机制是针对无状态的http比较好的一个会话管理机制；对前后端分离项目、用户量大的项目都更加友好；对移动端的支持也更好。</p><p>参考资料：</p><p><a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p><p><a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">https://www.cnblogs.com/moyand/p/9047978.html</a></p><p><a href="https://www.cnblogs.com/lyzg/p/6028341.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyzg/p/6028341.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于token机制与JWT标准&quot;&gt;&lt;a href=&quot;#关于token机制与JWT标准&quot; class=&quot;headerlink&quot; title=&quot;关于token机制与JWT标准&quot;&gt;&lt;/a&gt;关于token机制与JWT标准&lt;/h1&gt;&lt;p&gt;在传统的web单体项目中，我们的会话
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于二分查找（折半查找）的即记录</title>
    <link href="http://yoursite.com/posts/1/"/>
    <id>http://yoursite.com/posts/1/</id>
    <published>2019-06-05T07:36:18.000Z</published>
    <updated>2019-06-05T07:47:40.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于二分查找（折半查找）的即记录"><a href="#关于二分查找（折半查找）的即记录" class="headerlink" title="关于二分查找（折半查找）的即记录"></a>关于二分查找（折半查找）的即记录</h2><p>之前其实也学习过二分查找的理念，但是一直有一个模糊的地方就是中间元素的选取。</p><p>二分查找需要的数组需要是有序的。</p><h3 id="二分查找的步骤"><a href="#二分查找的步骤" class="headerlink" title="二分查找的步骤"></a>二分查找的步骤</h3><ol><li><p>确定数组的中间元素</p></li><li><p>将待查找元素与中间元素比较</p></li><li><p>如果大于中间元素，则到右边的数组查找，反之同理</p></li><li><p>如果中间元素等于待查找元素，那么查找成功。</p></li></ol><p>之前一直迷惑的一点就是第一步当中的中间元素的选取，因为数组会有两种情况，一种是元素的个数为偶数，另一种是数组元素个数为奇数。</p><p>今天到网上查找相关资料，才补上了这个基础的知识：</p><p>中间元素的选取可以使用如下公式：<code>mid = left + (right - left)/2;</code></p><p>这样不论当数组元素个数为偶数或者奇数的时候都可以正确选取到中间元素。</p><h3 id="二分查找的思想"><a href="#二分查找的思想" class="headerlink" title="二分查找的思想"></a>二分查找的思想</h3><p>其实二分查找是利用的算法设计思想中的 分治法，一步一步缩小查找范围，最终得到问题的解。</p><blockquote><p>分治法：将一个复杂的问题分解为多个相同或相似的子问题，再对子问题进行求解，进而得到问题的解。</p></blockquote><p>二分法的求解过程可以用二叉树来描述，对于一个有序的数组，根结点为最开始选取的中间元素，根结点的左右两个孩子分别为左数组的中间节点及右数组的中间节点，孩子的孩子同理；</p><p>所以通过查找树（判定树）可以看出查找的元素要经过几次比较以及跟哪些元素进行了比较。</p><h3 id="二分查找的时间复杂度"><a href="#二分查找的时间复杂度" class="headerlink" title="二分查找的时间复杂度"></a>二分查找的时间复杂度</h3><p>O(log2n)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于二分查找（折半查找）的即记录&quot;&gt;&lt;a href=&quot;#关于二分查找（折半查找）的即记录&quot; class=&quot;headerlink&quot; title=&quot;关于二分查找（折半查找）的即记录&quot;&gt;&lt;/a&gt;关于二分查找（折半查找）的即记录&lt;/h2&gt;&lt;p&gt;之前其实也学习过二分查找的理
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何给自己的网站添加小绿锁</title>
    <link href="http://yoursite.com/posts/2/"/>
    <id>http://yoursite.com/posts/2/</id>
    <published>2019-06-05T07:36:18.000Z</published>
    <updated>2019-06-05T07:47:46.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何给自己的网站添加小绿锁"><a href="#如何给自己的网站添加小绿锁" class="headerlink" title="如何给自己的网站添加小绿锁"></a>如何给自己的网站添加小绿锁</h1><h3 id="首先-要值得庆祝的是我的网站通过备案了"><a href="#首先-要值得庆祝的是我的网站通过备案了" class="headerlink" title="首先 要值得庆祝的是我的网站通过备案了"></a>首先 要值得庆祝的是我的网站通过备案了</h3><blockquote><p>之前我的博客是用的hexo博客，项目托管在github.io上，在本地使用Markdown写好文章 编译发布到git仓库就可以了。因此也无需备案。不过发现，github的访问速度不稳定，时快时慢就比较坑爹</p></blockquote><p>前一阵刚好赶上了阿里云的双11活动，直接298买了个最低配的3年，寻思买来放放博客，自己的小项目什么的都挺好。<br>刚好朋友最近推荐了一个java的开源博客项目 就是现在用的<a href="https://github.com/otale/tale" target="_blank" rel="noopener">tale</a>，而且hexo看久了 也腻了 而<a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">hexo</a>且没有后台，要手写markdown然后手动编译再git push 挺麻烦的。<br>所以我就在阿里云上搭了这个tale。功能比较简洁明了，用的是内置sqlite，总共没有几张表。不依赖容器。<br>如何安装tale大家直接点连接进去看就可以了，很简单 傻瓜式操作。</p><h3 id="接下来讲讲如何给你的网站添加小绿锁"><a href="#接下来讲讲如何给你的网站添加小绿锁" class="headerlink" title="接下来讲讲如何给你的网站添加小绿锁"></a>接下来讲讲如何给你的网站添加小绿锁</h3><blockquote><p>以下提到两个证书供应商都提供免费的ssl DV证书，letsencrypt三个月需要续期，可以自动续期，阿里云免费一年。</p></blockquote><h4 id="使用letsencrypt"><a href="#使用letsencrypt" class="headerlink" title="使用letsencrypt"></a>使用letsencrypt</h4><p>给站点添加ssl比较热门和方便的一个方法就是使用<a href="https://letsencrypt.org/" target="_blank" rel="noopener">letsencrypt</a>的<a href="https://certbot.eff.org/" target="_blank" rel="noopener">Certbot</a>自动给你的站点添加证书。<br>进入到certbot网站可以看到支持的服务器以及系统，本人推荐使用nginx，配置比较方便。<br>大概过程就是连接到你的服务器，安装certbot，配置一下nginx就ok了。这里不多讲certbot的使用了，因为我用的是阿里云的证书。</p><h4 id="阿里云ssl证书"><a href="#阿里云ssl证书" class="headerlink" title="阿里云ssl证书"></a>阿里云ssl证书</h4><p>如果你的域名也是在阿里云购买的话，这个过程就会更加方便。</p><ol><li>在阿里云购买的域名–》直接进入阿里云控制台 –域名 点击管理，里面有申请免费的ssl证书。</li><li>不是在阿里云购买的域名就要在阿里云搜索ssl进入根据提示申请一个免费的ssl证书，这里相较于 1 麻烦的就是要手动验证域名的所有权。可能要添加一条text类型的解析记录。</li></ol><p>现在假定你已经申请好了证书，可以看到证书管理界面你的证书那里有个下载，点击他，下载完你会拿到一个压缩包，里面有量个主要的文件，一个是以crt结尾的证书文件，一个是以key结尾的私钥文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.wasea.top/upload/2018/12/rk70ohtp0oj4arkfruvig1f9nc.png" alt title>                </div>                <div class="image-caption"></div>            </figure>  <p>剩下的步骤 阿里云的官方文档已经讲的很清楚了，详见：<a href="https://help.aliyun.com/knowledge_detail/95491.html?spm=a2c4g.11186623.2.12.36cb34f1dJH8Rt" target="_blank" rel="noopener">Nginx/Tengine服务器安装SSL证书</a>。  Tomcat的也有，详见：<a href="https://help.aliyun.com/knowledge_detail/95496.html?spm=a2c4g.11186623.2.14.36cb34f12nayEU" target="_blank" rel="noopener">Tomcat服务器安装SSL证书</a></p><blockquote><p>有一点要注意的是https使用的是443端口，http默认是80端口，所以要到阿里云的安全组添加开放你的443端口</p></blockquote><h3 id="后续配置"><a href="#后续配置" class="headerlink" title="后续配置"></a>后续配置</h3><p>做完上边的工作，你的网站应该就可以使用<code>https://your.domain</code>来访问了~  但细心的小伙伴会发现一个问题，这里一定要手动加上https的头，为什么人家的网站都可以直接使用域名访问自动跳转到https呢，其实这里也是后台要配置一个转发，将http的请求全部全部转到https。<br>下边是我完整的nginx配置文件 供大家参考。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"># For more information on configuration, see:</span><br><span class="line">#   * Official English Documentation: http://nginx.org/en/docs/</span><br><span class="line">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class="line">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class="line">    # for more information.</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  wasea.top www.wasea.top;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line">        rewrite ^(.*)$ https://$host$1 permanent;  # 重要的一个配置，可以自动转到https</span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass http://localhost:9000; # 我的tale博客默认使用9000端口</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># start aliyun ssl config</span><br><span class="line">server &#123;</span><br><span class="line"># listen 443;</span><br><span class="line"> listen       443 ssl http2 default_server;</span><br><span class="line"> listen       [::]:443 ssl http2 default_server;</span><br><span class="line"> server_name wasea.top www.wasea.top;</span><br><span class="line"> ssl on;</span><br><span class="line"> root html;</span><br><span class="line"> index index.html index.htm;</span><br><span class="line"> ssl_certificate   cert/a.pem;</span><br><span class="line"> ssl_certificate_key  cert/a.key;</span><br><span class="line"> ssl_session_timeout 5m;</span><br><span class="line"> ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line"> ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line"> ssl_prefer_server_ciphers on;</span><br><span class="line"> location / &#123;</span><br><span class="line">    add_header Content-Security-Policy upgrade-insecure-requests;</span><br><span class="line">    proxy_pass http://localhost:9000;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"># end aliyun ssl config</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>还有一点值得说的是，我这里省略了linux下一些细节的操作命令，例如给防火墙开放端口、安装nginx 等等其他，这些每个系统都有细微的区别，大家根据自己的系统来操作就好了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何给自己的网站添加小绿锁&quot;&gt;&lt;a href=&quot;#如何给自己的网站添加小绿锁&quot; class=&quot;headerlink&quot; title=&quot;如何给自己的网站添加小绿锁&quot;&gt;&lt;/a&gt;如何给自己的网站添加小绿锁&lt;/h1&gt;&lt;h3 id=&quot;首先-要值得庆祝的是我的网站通过备案了&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解MyBatis（一）</title>
    <link href="http://yoursite.com/posts/4/"/>
    <id>http://yoursite.com/posts/4/</id>
    <published>2019-06-05T07:36:18.000Z</published>
    <updated>2019-06-05T07:48:06.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解MyBatis（一）"><a href="#深入理解MyBatis（一）" class="headerlink" title="深入理解MyBatis（一）"></a>深入理解MyBatis（一）</h1><h2 id="MyBatis的基本运行过程"><a href="#MyBatis的基本运行过程" class="headerlink" title="MyBatis的基本运行过程"></a>MyBatis的基本运行过程</h2><ol><li><p>输入配置文件的文件流</p></li><li><p>使用SqlSessionFactoryBuilder根据配置文件创建SqlSessionFactory</p></li><li><p>通过SqlSessionFactory获取会话SqlSession</p></li><li><p>从SqlSession获取Executor</p></li><li><p>Executor读取并执行sql语句</p></li><li><p>StatementHandler处理jdbc的statement交互</p></li><li><p>TypeHandler负责设置参数</p></li><li><p>使用jdbc与数据库进行交互</p></li><li><p>jdbc返回结果集-》TypeHandler-》ResultHandler-》StatementHandler-》Executor-》SqlSession</p></li></ol><p>上述过程使用图片来描述会比较清晰。</p><h2 id="MyBatis的缓存机制"><a href="#MyBatis的缓存机制" class="headerlink" title="MyBatis的缓存机制"></a>MyBatis的缓存机制</h2><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>Executor在Mybatis中扮演者非常重要的一个角色，除了用来控制执行sql返回结果之外，它还有一个重要的指责就是缓存的管理。</p><p>在一个SqlSession的会话中，如果使用了同样的sql以及同样的参数两次以上，那么在第二次查询的时候就会命中mybatis的一级缓存，不再次查库；</p><p>在这个session会话中，如果有进行增删改操作，那么mybatis就会刷新缓存避免脏读现象的发生；</p><blockquote><p>一级缓存在Mybatis中是默认开启的。</p></blockquote><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存在Mybatis中其实也是默认开启的，二级缓存对应的配置项为<code>&lt;setting  name=&quot;cacheEnabled&quot;  value=&quot;true&quot;/&gt;</code> ，但是如果想要使用二级缓存需要在对应的mapper文件中加上如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启mapper的二级缓存， type:指定cache接口的实现类，mybatis默认使用PerpetualCache 要和ehcache整合，需要配置type为ehcache实现cache接口的类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.mybatis.caches.ehcache.EhcacheCache"</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不需要指定忽略type参数就可以了: <code>&lt;cache/&gt;</code>。</p><p>关于二级缓存的划分：既可以每个mapper使用自己的空间，也可以多个mapper共享一个空间（使用<code>&lt;cache-ref namespace=&quot;xx&quot;/&gt;</code>来配置）。</p><p>Mybatis对二级缓存的粒度控制很细，所以如果想要使用二级缓存，需要在指定的select标签中开启对该条语句进行缓存<code>cacheEnabled=true</code>。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>Mybatis实现二级缓存使用了装饰器模式，使用CachingExecutor装饰了Executor；从上文我们可以知道Executor控制了一级缓存，所以我们可以发现在一二级缓存同时开启式，mybatis是会优先使用二级缓存的。</p><blockquote><p>最后：关于实际应用中的缓存原则：尽量离客户端近；能用cdn的就cdn，能在nginx缓存的就在nginx缓存，接下来在控制层，业务层进行缓存，基本上在实际应用中不会使用到数据库级别的缓存。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解MyBatis（一）&quot;&gt;&lt;a href=&quot;#深入理解MyBatis（一）&quot; class=&quot;headerlink&quot; title=&quot;深入理解MyBatis（一）&quot;&gt;&lt;/a&gt;深入理解MyBatis（一）&lt;/h1&gt;&lt;h2 id=&quot;MyBatis的基本运行过程&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域资源共享CORS 详解</title>
    <link href="http://yoursite.com/posts/5/"/>
    <id>http://yoursite.com/posts/5/</id>
    <published>2019-06-05T07:36:18.000Z</published>
    <updated>2019-06-05T07:48:18.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨域资源共享CORS-详解"><a href="#跨域资源共享CORS-详解" class="headerlink" title="跨域资源共享CORS 详解"></a>跨域资源共享CORS 详解</h1><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;跨域资源共享CORS-详解&quot;&gt;&lt;a href=&quot;#跨域资源共享CORS-详解&quot; class=&quot;headerlink&quot; title=&quot;跨域资源共享CORS 详解&quot;&gt;&lt;/a&gt;跨域资源共享CORS 详解&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间</title>
    <link href="http://yoursite.com/posts/3/"/>
    <id>http://yoursite.com/posts/3/</id>
    <published>2019-02-03T04:33:18.000Z</published>
    <updated>2019-06-05T07:48:44.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间"><a href="#小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间" class="headerlink" title="小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间"></a>小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间</h1><h4 id="最近在做公司项目的时候，有一个需求是需要传入一个开始时间和一个结束时间。但是要按照统计的方式分别以日、周、月、季、年的方式来分组进行统计。"><a href="#最近在做公司项目的时候，有一个需求是需要传入一个开始时间和一个结束时间。但是要按照统计的方式分别以日、周、月、季、年的方式来分组进行统计。" class="headerlink" title="最近在做公司项目的时候，有一个需求是需要传入一个开始时间和一个结束时间。但是要按照统计的方式分别以日、周、月、季、年的方式来分组进行统计。"></a>最近在做公司项目的时候，有一个需求是需要传入一个开始时间和一个结束时间。但是要按照统计的方式分别以日、周、月、季、年的方式来分组进行统计。</h4><h4 id="这个问题其实有两个解决方案，一个是利用sql处理日期的字段格式化进行分组；另一种就是写一个通用一点的SQL，然后在service里处理这些日期，遍历调用这个接口。"><a href="#这个问题其实有两个解决方案，一个是利用sql处理日期的字段格式化进行分组；另一种就是写一个通用一点的SQL，然后在service里处理这些日期，遍历调用这个接口。" class="headerlink" title="这个问题其实有两个解决方案，一个是利用sql处理日期的字段格式化进行分组；另一种就是写一个通用一点的SQL，然后在service里处理这些日期，遍历调用这个接口。"></a>这个问题其实有两个解决方案，一个是利用sql处理日期的字段格式化进行分组；另一种就是写一个通用一点的SQL，然后在service里处理这些日期，遍历调用这个接口。</h4><h4 id="由于我们的需求对时间的要求比较复杂，并不可以按照自然月的方式进行统计，而是上个月26到本月25日为一个周期。比如统计2019年1月，实际上的开始和结束时间为：2018-12-26-2019-01-25。也正是因为这点，使用sql分组的方式就更加难以实现。"><a href="#由于我们的需求对时间的要求比较复杂，并不可以按照自然月的方式进行统计，而是上个月26到本月25日为一个周期。比如统计2019年1月，实际上的开始和结束时间为：2018-12-26-2019-01-25。也正是因为这点，使用sql分组的方式就更加难以实现。" class="headerlink" title="由于我们的需求对时间的要求比较复杂，并不可以按照自然月的方式进行统计，而是上个月26到本月25日为一个周期。比如统计2019年1月，实际上的开始和结束时间为：2018-12-26~2019-01-25。也正是因为这点，使用sql分组的方式就更加难以实现。"></a>由于我们的需求对时间的要求比较复杂，并不可以按照自然月的方式进行统计，而是上个月26到本月25日为一个周期。比如统计2019年1月，实际上的开始和结束时间为：2018-12-26~2019-01-25。也正是因为这点，使用sql分组的方式就更加难以实现。</h4><h4 id="所以我选用了第一个解决方案，就是在业务里处理这些时间。遂萌生了写这个工具类的想法。"><a href="#所以我选用了第一个解决方案，就是在业务里处理这些时间。遂萌生了写这个工具类的想法。" class="headerlink" title="所以我选用了第一个解决方案，就是在业务里处理这些时间。遂萌生了写这个工具类的想法。"></a>所以我选用了第一个解决方案，就是在业务里处理这些时间。遂萌生了写这个工具类的想法。</h4><h4 id="因为我们的业务需求比较特殊，所以下边贴上的代码还是按照自然月来处理的。"><a href="#因为我们的业务需求比较特殊，所以下边贴上的代码还是按照自然月来处理的。" class="headerlink" title="因为我们的业务需求比较特殊，所以下边贴上的代码还是按照自然月来处理的。"></a>因为我们的业务需求比较特殊，所以下边贴上的代码还是按照自然月来处理的。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传开始和结束日期 按日、周、月、季、年分割成一些时间区间</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateSeparateUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按日分隔</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> format</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForQuery 分隔好的时间区间 一个startTime和endTime为一组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForShow  显示在横轴的时间区间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">separateByDay</span><span class="params">(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeForQuery == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeForQuery = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeForShow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeForShow = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Calendar start = Calendar.getInstance();</span><br><span class="line">        start.setTime(startTime);</span><br><span class="line">        Calendar end = Calendar.getInstance();</span><br><span class="line">        end.setTime(endTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123;</span><br><span class="line">            HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            String startStr = format.format(<span class="keyword">new</span> Date(start.getTimeInMillis()));</span><br><span class="line">            map.put(<span class="string">"startTime"</span>, startStr + <span class="string">" 00:00:00"</span>); <span class="comment">// 按天算的话 开始和结束就是同一天</span></span><br><span class="line">            map.put(<span class="string">"endTime"</span>, startStr + <span class="string">" 23:59:59"</span>);</span><br><span class="line">            timeForQuery.add(map);</span><br><span class="line">            timeForShow.add(startStr.substring(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">            start.add(Calendar.DAY_OF_YEAR, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按星期分隔</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> format</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForQuery</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForShow</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">separateByWeek</span><span class="params">(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeForQuery == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeForQuery = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeForShow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeForShow = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Calendar start = Calendar.getInstance();</span><br><span class="line">        start.setFirstDayOfWeek(Calendar.MONDAY);</span><br><span class="line">        start.setTime(startTime);</span><br><span class="line">        Calendar end = Calendar.getInstance();</span><br><span class="line">        end.setTime(endTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123;</span><br><span class="line">            HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            String startStr = format.format(<span class="keyword">new</span> Date(start.getTimeInMillis()));</span><br><span class="line">            map.put(<span class="string">"startTime"</span>, startStr + <span class="string">" 00:00:00"</span>);</span><br><span class="line">            start.add(Calendar.DAY_OF_WEEK, <span class="comment">/*start.getActualMaximum(Calendar.DAY_OF_WEEK)*/</span><span class="number">8</span> - start.get(Calendar.DAY_OF_WEEK));</span><br><span class="line">            <span class="keyword">if</span> (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123;</span><br><span class="line">                <span class="comment">// 结束日期不能超过传来的最后日期</span></span><br><span class="line">                start.setTimeInMillis(end.getTimeInMillis());</span><br><span class="line">            &#125;</span><br><span class="line">            String weekEnd = format.format(<span class="keyword">new</span> Date(start.getTimeInMillis()));</span><br><span class="line">            map.put(<span class="string">"endTime"</span>, weekEnd + <span class="string">" 23:59:59"</span>);</span><br><span class="line">            timeForQuery.add(map);</span><br><span class="line">            timeForShow.add(startStr.substring(<span class="number">5</span>, <span class="number">10</span>) + <span class="string">"/"</span> + weekEnd.substring(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">            <span class="comment">// 加一天到下一周</span></span><br><span class="line">            start.add(Calendar.DAY_OF_WEEK, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按月分割</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> format</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForQuery</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForShow</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">separateByMonth</span><span class="params">(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeForQuery == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeForQuery = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeForShow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeForShow = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Calendar start = Calendar.getInstance();</span><br><span class="line">        start.setTime(startTime);</span><br><span class="line">        Calendar end = Calendar.getInstance();</span><br><span class="line">        end.setTime(endTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123;</span><br><span class="line">            HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            String startStr = format.format(<span class="keyword">new</span> Date(start.getTimeInMillis()));</span><br><span class="line">            map.put(<span class="string">"startTime"</span>, startStr + <span class="string">" 00:00:00"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// region 按照自然月方式处理</span></span><br><span class="line">             start.set(Calendar.DAY_OF_MONTH, start.getActualMaximum(Calendar.DAY_OF_MONTH));</span><br><span class="line">            <span class="comment">// endregion</span></span><br><span class="line">            <span class="keyword">if</span> (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123;</span><br><span class="line">                start.setTimeInMillis(end.getTimeInMillis());<span class="comment">// 不能超过end时期</span></span><br><span class="line">            &#125;</span><br><span class="line">            Date monthEnd = <span class="keyword">new</span> Date(start.getTimeInMillis());</span><br><span class="line">            map.put(<span class="string">"endTime"</span>, format.format(monthEnd) + <span class="string">" 23:59:59"</span>);</span><br><span class="line">            timeForQuery.add(map);</span><br><span class="line">            timeForShow.add(format.format(monthEnd).substring(<span class="number">2</span>, <span class="number">7</span>));</span><br><span class="line">            start.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>); <span class="comment">// 跳到下一天</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按季度拆分</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> format</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForQuery</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForShow</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">separateByQuarter</span><span class="params">(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeForQuery == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeForQuery = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeForShow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeForShow = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Calendar start = Calendar.getInstance();</span><br><span class="line">        start.setTime(startTime);</span><br><span class="line">        Calendar end = Calendar.getInstance();</span><br><span class="line">        end.setTime(endTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; quarter1 = Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        List&lt;Integer&gt; quarter2 = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        List&lt;Integer&gt; quarter3 = Arrays.asList(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">        List&lt;Integer&gt; quarter4 = Arrays.asList(<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> curMonth = start.get(Calendar.MONTH); <span class="comment">// 0-11</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理第一季度的月份</span></span><br><span class="line">            <span class="keyword">if</span> (quarter1.contains(curMonth)) &#123;</span><br><span class="line">                handleQuarterOnce(quarter1, <span class="number">1</span>, timeForQuery, timeForShow, format, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理第二季度的月份</span></span><br><span class="line">            <span class="keyword">if</span> (quarter2.contains(curMonth)) &#123;</span><br><span class="line">                handleQuarterOnce(quarter2, <span class="number">2</span>, timeForQuery, timeForShow, format, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理第三季度的月份</span></span><br><span class="line">            <span class="keyword">if</span> (quarter3.contains(curMonth)) &#123;</span><br><span class="line">                handleQuarterOnce(quarter3, <span class="number">3</span>, timeForQuery, timeForShow, format, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理第四季度的月份</span></span><br><span class="line">            <span class="keyword">if</span> (quarter4.contains(curMonth)) &#123;</span><br><span class="line">                handleQuarterOnce(quarter4, <span class="number">4</span>, timeForQuery, timeForShow, format, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按年分隔</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> format</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForQuery</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForShow</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">separateByYear</span><span class="params">(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeForQuery == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeForQuery = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeForShow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timeForShow = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Calendar start = Calendar.getInstance();</span><br><span class="line">        start.setTime(startTime);</span><br><span class="line">        Calendar end = Calendar.getInstance();</span><br><span class="line">        end.setTime(endTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123;</span><br><span class="line">            HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            String startStr = format.format(<span class="keyword">new</span> Date(start.getTimeInMillis()));</span><br><span class="line">            map.put(<span class="string">"startTime"</span>, startStr + <span class="string">" 00:00:00"</span>);</span><br><span class="line">            <span class="comment">// region按自然月处理</span></span><br><span class="line">            start.set(Calendar.DAY_OF_YEAR, start.getActualMaximum(Calendar.DAY_OF_YEAR));</span><br><span class="line">            <span class="comment">// endregion</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123;</span><br><span class="line">                start.setTimeInMillis(end.getTimeInMillis());</span><br><span class="line">            &#125;</span><br><span class="line">            String yearEnd = format.format(<span class="keyword">new</span> Date(start.getTimeInMillis()));</span><br><span class="line">            map.put(<span class="string">"endTime"</span>, yearEnd + <span class="string">" 23:59:59"</span>);</span><br><span class="line">            timeForQuery.add(map);</span><br><span class="line">            timeForShow.add(yearEnd.substring(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">            start.add(Calendar.DAY_OF_YEAR, <span class="number">1</span>);<span class="comment">// 跳下一天</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************************************************私有方法*********************************************************/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 近供分割季度的方法使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> monthInQuarter List&lt;Integer&gt; quarter1 = Arrays.asList(0, 1, 2);</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> quarter        1\2\3\4</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForQuery</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeForShow</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> format</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleQuarterOnce</span><span class="params">(List&lt;Integer&gt; monthInQuarter, <span class="keyword">int</span> quarter, List&lt;Map&lt;String, String&gt;&gt; timeForQuery,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          List&lt;String&gt; timeForShow, SimpleDateFormat format, Calendar start, Calendar end)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        String startStr = format.format(start.getTimeInMillis());</span><br><span class="line">        map.put(<span class="string">"startTime"</span>, startStr + <span class="string">" 00:00:00"</span>);</span><br><span class="line">        <span class="comment">// 设置为季度最后一天</span></span><br><span class="line">        <span class="comment">// region 自然月的方式处理</span></span><br><span class="line">        start.set(Calendar.MONTH, monthInQuarter.get(<span class="number">2</span>));</span><br><span class="line">        start.set(Calendar.DAY_OF_MONTH, start.getActualMaximum(Calendar.DAY_OF_MONTH));</span><br><span class="line">        <span class="comment">// endregion</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止超出时间范围</span></span><br><span class="line">        <span class="keyword">if</span> (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123;</span><br><span class="line">            start.setTimeInMillis(end.getTimeInMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        String quarterEnd = format.format(<span class="keyword">new</span> Date(start.getTimeInMillis()));</span><br><span class="line">        map.put(<span class="string">"endTime"</span>, quarterEnd + <span class="string">" 23:59:59"</span>);</span><br><span class="line">        timeForQuery.add(map);</span><br><span class="line">        timeForShow.add(quarterEnd.substring(<span class="number">0</span>, <span class="number">4</span>) + <span class="string">"年"</span> + quarter + <span class="string">"季度"</span>);</span><br><span class="line">        start.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);<span class="comment">// +1天</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****************************************************测试*********************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line">        instance.add(Calendar.DAY_OF_YEAR, <span class="number">300</span>);</span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"><span class="comment">//        Date now = new Date();</span></span><br><span class="line"><span class="comment">//        Date end = new Date(instance.getTimeInMillis());</span></span><br><span class="line">        Date now = format.parse(<span class="string">"2017-09-26"</span>);</span><br><span class="line">        Date end = format.parse(<span class="string">"2019-04-20"</span>);</span><br><span class="line"><span class="comment">//        List&lt;Map&lt;String, String&gt;&gt; maps = separateByDay(new Date(), new Date(instance.getTimeInMillis()), format);</span></span><br><span class="line"><span class="comment">//        System.out.println(maps);</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Map&lt;String, String&gt;&gt; timeForQuery = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; timeForShow = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//        separateByWeek(now, end, format, timeForQuery, timeForShow);</span></span><br><span class="line"><span class="comment">//        separateByMonth(now, end, format, timeForQuery, timeForShow);</span></span><br><span class="line"><span class="comment">//        assert (!ObjectUtils.hasLength(timeForQuery)):"OJBK";</span></span><br><span class="line"><span class="comment">//        separateByQuarter(now, end, format, timeForQuery, timeForShow);</span></span><br><span class="line">        separateByYear(now, end, format, timeForQuery, timeForShow);</span><br><span class="line">        System.out.println(timeForQuery);</span><br><span class="line">        System.out.println(timeForShow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间&quot;&gt;&lt;a href=&quot;#小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间&quot; class=&quot;headerlink&quot; title=&quot;小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区
      
    
    </summary>
    
    
  </entry>
  
</feed>
