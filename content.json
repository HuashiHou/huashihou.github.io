{"meta":{"title":"Wayne's blog","subtitle":"一个有情调的程序员","description":null,"author":"侯骅十","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-06-05T08:43:39.000Z","updated":"2019-06-05T08:43:56.155Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-05T08:42:46.000Z","updated":"2019-06-05T08:43:21.820Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深入理解Tomcat之一：Tomcat基础架构","slug":"深入理解Tomcat之一：Tomcat基础架构","date":"2019-07-06T09:26:18.000Z","updated":"2019-07-06T09:00:21.186Z","comments":true,"path":"posts/24480/","link":"","permalink":"http://yoursite.com/posts/24480/","excerpt":"","text":"深入理解Tomcat之一：Tomcat基础架构Tomcat的定义（来自wiki百科）Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如**Tomcat管理和控制平台、安全域管理和Tomcat阀等。 由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。 Http服务器与应用服务器之前在技术讨论群里看到一个群友提问：nginx和tomcat有什么区别呀？其实提出这种问题就可以得知他对两个服务器的基础概念都还不是很清晰。 严格来讲，Nginx、Apache这些叫做Http Server； 而Tomcat是Application Server，更准确的说，是一个Servlet、Jsp容器。 一个 HTTP Server 关心的是 HTTP 协议层面的传输和访问控制，所以在 Apache/Nginx 上你可以看到代理、负载均衡等功能。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。一个 HTTP Server 始终只是把服务器上的文件如实的通过 HTTP 协议传输给客户端。 对于 Tomcat 来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。 回到上面的问题，在我的理解看来，Nginx更像一个协调管理者的角色，而Tomcat用“容器”这个词语形容它会更加形象贴切一点。 Tomcat的整体架构 Tomcat最顶层的容器是Server， 代表整个服务器，从上图可以看出一个 Server至少包含 一个Service，用于具体提供服务。 两个主要组件Connecter用于处理连接相关的事，并提供Socket与Request和Response相关的转化; 基本功能一个Connecter将在某个指定的端口上侦听客户请求，接收浏览器的发过来的 tcp 连接请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据，然后会产生一个线程来处理这个请求并把产生的 Request 和 Response 对象传给处理Engine(Container中的一部分)，从Engine出获得响应并返回客户。 Tomcat中有两个经典的Connector， 一个直接侦听来自Browser的HTTP请求， 另外一个来自其他的WebServer请求。 HTTP/1.1 Connector在端口8080处侦听来自客户Browser的HTTP请求，AJP/1.3 Connector在端口8009处侦听其他Web Server（其他的HTTP服务器）的Servlet/JSP请求。 Connector 最重要的功能就是接收连接请求然后分配线程让 Container 来处理这个请求，所以这必然是多线程的，多线程的处理是 Connector 设计的核心。 Connector 中具体是用ProtocolHandler 来处理请求的，不同的ProtocolHandler 代表不同的连接类型，比如， Http11Protocol 使用的是普通Socket 来连接的， Http 11 NioProtocol 使用的是NioSocket 来连接的。 ProtocolHandler 里面有3 个非常重要的组件： Endpoint 、Processor 和Adapter。 Endpoint用于处理底层Socket 的网络连接， Acceptor 用于监昕请求 AsyncTimeout 用于检查异步request 的超时 Handler 用于处理接收到的Socket，在内部调用了Processor 进行处理。 Processor 用于将Endpoint 接收到的Socket 封装成Request, Adapter 用于将封装好的Request 交给Container 进行具体处理。 也就是说Endpoint用来实现TCP/IP 协议， Processor 用来实现HTTP 协议， Adapter 将请求适配到Servlet 容器进行具体处理。 Container用于封装和管理Servlet，以及具体处理Request请求； Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器。 4个子容器的作用分别是： （1）Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine； （2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点； （3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件； （4）Wrapper：每一Wrapper封装着一个Servlet； 其他组件 Jasper：负责jsp页面的解析，jsp属性的验证,同时负责将jsp动态转换为java代码并编译成class。 Naming：资源管理，负责数据库连接池、EJB、mail等通过JDNI获取的内容。 Session：会话管理的组件 Logging：日志相关 JMX：性能监控等","categories":[],"tags":[]},{"title":"深入理解Tomcat之二：自己动手实现一个简单的Tomcat","slug":"深入理解Tomcat之二：自己动手实现一个简单的tomcat","date":"2019-07-06T09:26:18.000Z","updated":"2019-07-06T08:59:33.482Z","comments":true,"path":"posts/6083/","link":"","permalink":"http://yoursite.com/posts/6083/","excerpt":"","text":"深入理解Tomcat之二：自己动手实现一个简单的Tomcat学习一个新的知识的过程就是 看别人的文章、听别人讲、自己查资料、自己给别人讲。我们对于新知识的认识成都以及理解深度都是在整个过程中不断的加深的。所以我一直提倡大家要乐于分享，当你给别人用组织系统化的语言或者文章将你头脑中的知识输出来，你就会发现，你对之前知识的理解又加深了一个程度。 而这一篇手写tomcat，其实也是我在学习tomcat架构的过程中，模仿别人的代码自己再手敲一遍，最后将思路和实现过程整理成文，输出给大家。 主要需求 监听请求端口 封装请求和返回 对请求进行处理 上面就是mini tomcat的类图 各个类MyRequest自己封装的请求类，相当于servlet中的HttpRequest。 inputStream来自于socket的输入流，用浏览器访问的时候就会包含了整个请求的报文 解析http请求头的第一行 拿出协议中的 GET 或者 POST 还有请求url 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 自己封装的请求 */public class MyRequest &#123; private String url; private String method; public MyRequest(InputStream inputStream) throws IOException &#123; String httpRequest = \"\"; byte[] requestBytes = new byte[1024]; int length = inputStream.read(requestBytes); if(length&gt;0)&#123; httpRequest = new String(requestBytes, 0, length); &#125; // 解析内容 // 第一行是http头部内容 String httpHead = httpRequest.split(\"\\n\")[0]; url = httpHead.split(\"\\\\s\")[1]; method = httpHead.split(\"\\\\s\")[0]; System.out.println(\"接收到请求-------》\"); System.out.println(\"请求信息 ：\" + toString()); &#125; @Override public String toString() &#123; return \"url: \" + url + \", method: \" + method; &#125; public String getUrl() &#123; return url; &#125; public String getMethod() &#123; return method; &#125;&#125; MyResponse 要点在于手动按照http协议的格式进行响应，这样浏览器才可以识别 1234567891011121314151617181920212223242526272829/** * 自己封装的响应 */public class MyResponse &#123; private OutputStream outputStream; public MyResponse(OutputStream outputStream) &#123; this.outputStream = outputStream; &#125; public void write(String content) throws IOException &#123; if(outputStream!=null) &#123; StringBuffer httpResponse = new StringBuffer(); // 按照http响应格式输出 httpResponse.append(\"HTTP/1.1 200 OK\\n\") .append(\"Content-Type: text/html\\n\") .append(\"\\r\\n\") .append(\"&lt;html&gt;&lt;body&gt;\") .append(content) .append(\"&lt;/body&gt;&lt;/html&gt;\"); System.out.println(\"返回信息：\"+httpResponse.toString()); outputStream.write(httpResponse.toString().getBytes()); outputStream.close(); &#125; &#125;&#125; MyServlet抽象的Servlet，可以继承它来有很多不同的实现。 service 方法根据请求的方法分发到get或者post进行处理，这里与 12345678910111213141516171819/** * 自己封装的Servlet * 继承后做不同的实现 */public abstract class MyServlet &#123; public abstract void doGet(MyRequest httpRequest, MyResponse httpResponse); public abstract void doPost(MyRequest httpRequest, MyResponse httpResponse); public void service(MyRequest request, MyResponse response) &#123; if(request!=null) &#123; if (\"POST\".equalsIgnoreCase(request.getMethod())) &#123; doPost(request, response); &#125; else if (\"GET\".equalsIgnoreCase(request.getMethod())) &#123; doGet(request, response); &#125; &#125; &#125;&#125; HelloServlet1234567891011121314151617181920212223/** * Servlet的实现类，在post get中添加具体的业务逻辑 * 以前使用servlet编程的时候也是这样的实现方法 */public class HelloServlet extends MyServlet &#123; @Override public void doGet(MyRequest httpRequest, MyResponse httpResponse) &#123; try &#123; httpResponse.write(\"get method in hello servlet !!\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void doPost(MyRequest httpRequest, MyResponse httpResponse) &#123; try &#123; httpResponse.write(\"post method in hello servlet\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ServletMapping其实是一个Bean，简单封装了配置信息，方便我们读取。 123456789101112131415161718192021222324252627282930313233343536public class ServletMapping &#123; private String servletName; private String url; private String clazz; public ServletMapping(String servletName, String url, String clazz) &#123; this.servletName = servletName; this.url = url; this.clazz = clazz; &#125; public String getServletName() &#123; return servletName; &#125; public void setServletName(String servletName) &#123; this.servletName = servletName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getClazz() &#123; return clazz; &#125; public void setClazz(String clazz) &#123; this.clazz = clazz; &#125;&#125; ServletMappingConfig存着一个列表来保存配置，真正tomcat也不是这样实现的。我们只是为了效果方便实现。 1234567891011/** * 这里由于是demo 采用简洁的方式先进行配置 */public class ServletMappingConfig &#123; public static List&lt;ServletMapping&gt; config = new ArrayList&lt;ServletMapping&gt;(); // 在真正的tomcat中是扫描web.xml的配置来初始化ServletMapping static &#123; config.add(new ServletMapping(\"hello\", \"/hello\", \"com.practice.HelloServlet\")); &#125;&#125; MyTomcatminitomcat的核心类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class MyTomcat &#123; private int port = 8080; private HashMap&lt;String, String&gt; mapping = new HashMap&lt;String, String&gt;(); public MyTomcat(int port) &#123; this.port = port; &#125; /** * 使用socket不断等候接收新的请求 */ void start() &#123; initservletMappings(); ServerSocket socket = null; try &#123; socket = new ServerSocket(port); System.out.println(\"Tomcat 启动成功～～\"); while (true) &#123; Socket accept = socket.accept(); InputStream inputStream = accept.getInputStream(); OutputStream outputStream = accept.getOutputStream(); MyRequest myRequest = new MyRequest(inputStream); MyResponse myResponse = new MyResponse(outputStream); dispatch(myRequest, myResponse);// socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 读取配置文件初始化servletMapping */ private void initservletMappings() &#123; for (ServletMapping servletMapping : ServletMappingConfig.config) &#123; mapping.put(servletMapping.getUrl(), servletMapping.getClazz()); &#125; &#125; /** * 读取配置找到对应的Servlet类，使用反射创建实例处理请求 * @param request * @param response */ private void dispatch(MyRequest request, MyResponse response) &#123; String url = request.getUrl(); String clazz = mapping.get(url); if(clazz==null || clazz==\"\")&#123; System.out.println(\"没有找到请求对应的链接:\" + url); System.out.println(); return; &#125; try &#123; Class&lt;MyServlet&gt; aClass = (Class&lt;MyServlet&gt;) Class.forName(clazz); MyServlet myServlet = aClass.newInstance(); myServlet.service(request, response); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); System.out.println(\"不存在该类\"); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; /** * 启动tomcat * @param args */ public static void main(String[] args) &#123; new MyTomcat(8081).start(); &#125;&#125; 最后我们运行main方法，在浏览器中访问localhost:8081/hello 就可以看到效果啦！ 总结这个tomcat很mini ，只简单实现了基本的功能，大家可以在这个基础上不断添加其他的功能，让这个minitomcat越来越接近真正的tomct！！","categories":[],"tags":[]},{"title":"Spring中的事件简述与Guava的EventBus","slug":"Spring中的事件简述与Guava的EventBus","date":"2019-06-11T09:26:18.000Z","updated":"2019-06-11T09:27:22.325Z","comments":true,"path":"posts/38349/","link":"","permalink":"http://yoursite.com/posts/38349/","excerpt":"","text":"Spring中的事件简述与Guava的EventBusSpring的事件关键类 org.springframework.context.ApplicationEvent org.springframework.context.ApplicationListener 使用容器触发事件，applicationContext发布事件。 简单实现逻辑 自定义订阅和通知事件，继承ApplicationEvent 定义事件监听器，实现ApplicationListener 使用容器发布事件（订阅、通知） 拓展@EventListener注解为了加强@EventListener的功能，Spring 4.2开始支持使用SpEL表达式定义事件触发的条件。 下面为使用了该注解的的一个实例： Event： 123456789101112131415161718192021222324public class TestEvent extends ApplicationEvent &#123; public boolean isImport; public TestEvent(Object source, boolean isImport) &#123; super(source); this.isImport = isImport; &#125; public boolean isImport() &#123; return isImport; &#125; public void setImport(boolean anImport) &#123; isImport = anImport; &#125; @Override public String toString() &#123; return \"TestEvent&#123;\" + \"isImport=\" + isImport + '&#125;'; &#125;&#125; Listener: 123456789@Componentpublic class EventHandler &#123; // 当isImport为true的时候才会打印 @EventListener(condition=\"#testEvent.isImport\") public void TestEventTest(TestEvent testEvent) &#123; System.out.println(\"==============TestEvent==============\" + testEvent.toString()); &#125;&#125; 拓展Google Guava中的EventBusGoogleGuava是谷歌在日常开发过程中总结积累出来的一个类库，包含了许多常用的工具等。 Guava的优点： 高效设计良好的API，被Google的开发者设计，实现和使用 遵循高效的java语法实践 使代码更刻度，简洁，简单 节约时间，资源，提高生产力 Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如： 集合 [collections] 缓存 [caching] 原生类型支持 [primitives support] 并发库 [concurrency libraries] 通用注解 [common annotations] 字符串处理 [string processing] I/O 等等。 这里我们主要介绍Guava中的事件总线EventBus。使用Guava的事件总线就不用再像上面Spring中的继承实现接口的方法。只需要在指定的事件处理方法上加@Subscribe注解即可。 消息封装类： 12345678910public class TestEvent &#123; private final int message; public TestEvent(int message) &#123; this.message = message; System.out.println(\"event message:\"+message); &#125; public int getMessage() &#123; return message; &#125;&#125; 消息接收类： 12345678910111213public class EventListener &#123; public int lastMessage = 0; @Subscribe public void listen(TestEvent event) &#123; lastMessage = event.getMessage(); System.out.println(\"Message:\"+lastMessage); &#125; public int getLastMessage() &#123; return lastMessage; &#125;&#125; 测试类及输出结果： 12345678910111213141516171819202122232425public class TestEventBus &#123; @Test public void testReceiveEvent() throws Exception &#123; EventBus eventBus = new EventBus(\"test\"); EventListener listener = new EventListener(); eventBus.register(listener); eventBus.post(new TestEvent(200)); eventBus.post(new TestEvent(300)); eventBus.post(new TestEvent(400)); System.out.println(\"LastMessage:\"+listener.getLastMessage()); &#125;&#125;//输出信息event message:200Message:200event message:300Message:300event message:400Message:400LastMessage:400 以上即是EventBus的简单使用。 参考资料:https://shimo.im/docs/z7ggA56biOAfAdht/read https://www.cnblogs.com/peida/p/EventBus.html","categories":[],"tags":[]},{"title":"关于二分查找（折半查找）的即记录","slug":"关于二分查找（折半查找）的即记录","date":"2019-06-05T07:36:18.000Z","updated":"2019-06-05T07:47:40.675Z","comments":true,"path":"posts/1/","link":"","permalink":"http://yoursite.com/posts/1/","excerpt":"","text":"关于二分查找（折半查找）的即记录之前其实也学习过二分查找的理念，但是一直有一个模糊的地方就是中间元素的选取。 二分查找需要的数组需要是有序的。 二分查找的步骤 确定数组的中间元素 将待查找元素与中间元素比较 如果大于中间元素，则到右边的数组查找，反之同理 如果中间元素等于待查找元素，那么查找成功。 之前一直迷惑的一点就是第一步当中的中间元素的选取，因为数组会有两种情况，一种是元素的个数为偶数，另一种是数组元素个数为奇数。 今天到网上查找相关资料，才补上了这个基础的知识： 中间元素的选取可以使用如下公式：mid = left + (right - left)/2; 这样不论当数组元素个数为偶数或者奇数的时候都可以正确选取到中间元素。 二分查找的思想其实二分查找是利用的算法设计思想中的 分治法，一步一步缩小查找范围，最终得到问题的解。 分治法：将一个复杂的问题分解为多个相同或相似的子问题，再对子问题进行求解，进而得到问题的解。 二分法的求解过程可以用二叉树来描述，对于一个有序的数组，根结点为最开始选取的中间元素，根结点的左右两个孩子分别为左数组的中间节点及右数组的中间节点，孩子的孩子同理； 所以通过查找树（判定树）可以看出查找的元素要经过几次比较以及跟哪些元素进行了比较。 二分查找的时间复杂度O(log2n)","categories":[],"tags":[]},{"title":"如何给自己的网站添加小绿锁","slug":"如何给自己的网站添加小绿锁","date":"2019-06-05T07:36:18.000Z","updated":"2019-06-05T07:47:46.773Z","comments":true,"path":"posts/2/","link":"","permalink":"http://yoursite.com/posts/2/","excerpt":"","text":"如何给自己的网站添加小绿锁首先 要值得庆祝的是我的网站通过备案了 之前我的博客是用的hexo博客，项目托管在github.io上，在本地使用Markdown写好文章 编译发布到git仓库就可以了。因此也无需备案。不过发现，github的访问速度不稳定，时快时慢就比较坑爹 前一阵刚好赶上了阿里云的双11活动，直接298买了个最低配的3年，寻思买来放放博客，自己的小项目什么的都挺好。刚好朋友最近推荐了一个java的开源博客项目 就是现在用的tale，而且hexo看久了 也腻了 而hexo且没有后台，要手写markdown然后手动编译再git push 挺麻烦的。所以我就在阿里云上搭了这个tale。功能比较简洁明了，用的是内置sqlite，总共没有几张表。不依赖容器。如何安装tale大家直接点连接进去看就可以了，很简单 傻瓜式操作。 接下来讲讲如何给你的网站添加小绿锁 以下提到两个证书供应商都提供免费的ssl DV证书，letsencrypt三个月需要续期，可以自动续期，阿里云免费一年。 使用letsencrypt给站点添加ssl比较热门和方便的一个方法就是使用letsencrypt的Certbot自动给你的站点添加证书。进入到certbot网站可以看到支持的服务器以及系统，本人推荐使用nginx，配置比较方便。大概过程就是连接到你的服务器，安装certbot，配置一下nginx就ok了。这里不多讲certbot的使用了，因为我用的是阿里云的证书。 阿里云ssl证书如果你的域名也是在阿里云购买的话，这个过程就会更加方便。 在阿里云购买的域名–》直接进入阿里云控制台 –域名 点击管理，里面有申请免费的ssl证书。 不是在阿里云购买的域名就要在阿里云搜索ssl进入根据提示申请一个免费的ssl证书，这里相较于 1 麻烦的就是要手动验证域名的所有权。可能要添加一条text类型的解析记录。 现在假定你已经申请好了证书，可以看到证书管理界面你的证书那里有个下载，点击他，下载完你会拿到一个压缩包，里面有量个主要的文件，一个是以crt结尾的证书文件，一个是以key结尾的私钥文件。 剩下的步骤 阿里云的官方文档已经讲的很清楚了，详见：Nginx/Tengine服务器安装SSL证书。 Tomcat的也有，详见：Tomcat服务器安装SSL证书 有一点要注意的是https使用的是443端口，http默认是80端口，所以要到阿里云的安全组添加开放你的443端口 后续配置做完上边的工作，你的网站应该就可以使用https://your.domain来访问了~ 但细心的小伙伴会发现一个问题，这里一定要手动加上https的头，为什么人家的网站都可以直接使用域名访问自动跳转到https呢，其实这里也是后台要配置一个转发，将http的请求全部全部转到https。下边是我完整的nginx配置文件 供大家参考。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name wasea.top www.wasea.top; root /usr/share/nginx/html; rewrite ^(.*)$ https://$host$1 permanent; # 重要的一个配置，可以自动转到https # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; proxy_pass http://localhost:9000; # 我的tale博客默认使用9000端口 &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;# start aliyun ssl configserver &#123;# listen 443; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name wasea.top www.wasea.top; ssl on; root html; index index.html index.htm; ssl_certificate cert/a.pem; ssl_certificate_key cert/a.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; add_header Content-Security-Policy upgrade-insecure-requests; proxy_pass http://localhost:9000; &#125;&#125;# end aliyun ssl config&#125; 还有一点值得说的是，我这里省略了linux下一些细节的操作命令，例如给防火墙开放端口、安装nginx 等等其他，这些每个系统都有细微的区别，大家根据自己的系统来操作就好了。","categories":[],"tags":[]},{"title":"深入理解MyBatis（一）","slug":"深入理解MyBatis（一）","date":"2019-06-05T07:36:18.000Z","updated":"2019-06-05T07:48:06.690Z","comments":true,"path":"posts/4/","link":"","permalink":"http://yoursite.com/posts/4/","excerpt":"","text":"深入理解MyBatis（一）MyBatis的基本运行过程 输入配置文件的文件流 使用SqlSessionFactoryBuilder根据配置文件创建SqlSessionFactory 通过SqlSessionFactory获取会话SqlSession 从SqlSession获取Executor Executor读取并执行sql语句 StatementHandler处理jdbc的statement交互 TypeHandler负责设置参数 使用jdbc与数据库进行交互 jdbc返回结果集-》TypeHandler-》ResultHandler-》StatementHandler-》Executor-》SqlSession 上述过程使用图片来描述会比较清晰。 MyBatis的缓存机制一级缓存Executor在Mybatis中扮演者非常重要的一个角色，除了用来控制执行sql返回结果之外，它还有一个重要的指责就是缓存的管理。 在一个SqlSession的会话中，如果使用了同样的sql以及同样的参数两次以上，那么在第二次查询的时候就会命中mybatis的一级缓存，不再次查库； 在这个session会话中，如果有进行增删改操作，那么mybatis就会刷新缓存避免脏读现象的发生； 一级缓存在Mybatis中是默认开启的。 二级缓存二级缓存在Mybatis中其实也是默认开启的，二级缓存对应的配置项为&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; ，但是如果想要使用二级缓存需要在对应的mapper文件中加上如下配置 12&lt;!-- 开启mapper的二级缓存， type:指定cache接口的实现类，mybatis默认使用PerpetualCache 要和ehcache整合，需要配置type为ehcache实现cache接口的类型 --&gt;&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt;&lt;/cache&gt; 如果不需要指定忽略type参数就可以了: &lt;cache/&gt;。 关于二级缓存的划分：既可以每个mapper使用自己的空间，也可以多个mapper共享一个空间（使用&lt;cache-ref namespace=&quot;xx&quot;/&gt;来配置）。 Mybatis对二级缓存的粒度控制很细，所以如果想要使用二级缓存，需要在指定的select标签中开启对该条语句进行缓存cacheEnabled=true。 实现原理Mybatis实现二级缓存使用了装饰器模式，使用CachingExecutor装饰了Executor；从上文我们可以知道Executor控制了一级缓存，所以我们可以发现在一二级缓存同时开启式，mybatis是会优先使用二级缓存的。 最后：关于实际应用中的缓存原则：尽量离客户端近；能用cdn的就cdn，能在nginx缓存的就在nginx缓存，接下来在控制层，业务层进行缓存，基本上在实际应用中不会使用到数据库级别的缓存。","categories":[],"tags":[]},{"title":"跨域资源共享CORS 详解","slug":"跨域资源共享CORS 详解","date":"2019-06-05T07:36:18.000Z","updated":"2019-06-05T07:48:18.440Z","comments":true,"path":"posts/5/","link":"","permalink":"http://yoursite.com/posts/5/","excerpt":"","text":"跨域资源共享CORS 详解http://www.ruanyifeng.com/blog/2016/04/cors.html","categories":[],"tags":[]},{"title":"关于token机制与JWT标准","slug":"关于token机制与JWT标准","date":"2019-06-05T07:36:18.000Z","updated":"2019-06-05T07:49:13.679Z","comments":true,"path":"posts/33574/","link":"","permalink":"http://yoursite.com/posts/33574/","excerpt":"","text":"关于token机制与JWT标准在传统的web单体项目中，我们的会话通常使用session和cookie两样来实现。 传统的cookie/session实现session是保存在服务器端的会话，使用cookie在客户端保存一个session id，每次发送请求的时候带上这个cookie服务端就可以很容易的了解当前用户是否与服务端建立了会话，以及会话是否过期等等。在单体项目中的这种实现机制相对来说是比较方便的。 使用这种机制存在的问题： 当我们的项目变得越来越大，用户数量越来越多之后，每新建一个会话服务器就要多消耗空间来存储空间，这将使服务器内存的开销不断增加； 跨域问题，很多项目使用前后端分离开发，而且前后端也部署在不同的域，这将导致一系列跨域问题的发生； 可拓展性，只在服务器内存中存储session限制了可拓展性能； 针对以上痛点，token机制的出现很好的解决了问题。 token机制使用token机制时，当用户请求时，会检查用户是否有携带token信息，或者token是否过期；未登录的话叫用户进行登录，然后服务端生成一串token返回给浏览器，可以存储在cookie或者localStorage里面。以后用户每一次发送的请求都会带上这个token。 token的组成一般是一些基础的信息，加上一个签名。这样服务器就无需存储session，每当收到一个新的请求，对token的签名进行验证，验证成功就可以进行下一步的操作。而且通常token可以存储在数据库中。 JWT（Json Web Token）广义上的jwt其实是token机制的一个实现标准，狭义上的jwt即是我们每次请求携带的token串。 jwt串由3部分组成，下面是一个例子： 123eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 第一部分为header为json格式 1234&#123; \"alg\": \"HS256\", 加密算法类型 \"typ\": \"JWT\" token类型&#125; 第二部分为payload 同样为json： 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, 保留claim subject代表这个jwt的主体 &quot;name&quot;: &quot;John Doe&quot;, 自定义的claim &quot;iat&quot;: 1516239022 保留claim 时间戳 代表jwt的签发时间&#125; 第三部分就是用header中指定的算法结合payload的内容制造出的签名。 jwt串只是使用base64编码，并没有进行加密，所以任何人获取到jwt串都可以拿到其中传输的内容。 当服务端获取到这一tokne之后，会有如下事件流： 使用base64将jwt串进行还原 使用header中的算法对签名部分进行还原 对比直接从jwt中解析出的payload部分和使用算法还原的payload 如果不一致 验证失败 一致则验证成功 总结token机制是针对无状态的http比较好的一个会话管理机制；对前后端分离项目、用户量大的项目都更加友好；对移动端的支持也更好。 参考资料： https://jwt.io/ https://www.cnblogs.com/moyand/p/9047978.html https://www.cnblogs.com/lyzg/p/6028341.html","categories":[],"tags":[]},{"title":"小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间","slug":"小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间","date":"2019-02-03T04:33:18.000Z","updated":"2019-06-05T07:48:44.857Z","comments":true,"path":"posts/3/","link":"","permalink":"http://yoursite.com/posts/3/","excerpt":"","text":"小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间最近在做公司项目的时候，有一个需求是需要传入一个开始时间和一个结束时间。但是要按照统计的方式分别以日、周、月、季、年的方式来分组进行统计。这个问题其实有两个解决方案，一个是利用sql处理日期的字段格式化进行分组；另一种就是写一个通用一点的SQL，然后在service里处理这些日期，遍历调用这个接口。由于我们的需求对时间的要求比较复杂，并不可以按照自然月的方式进行统计，而是上个月26到本月25日为一个周期。比如统计2019年1月，实际上的开始和结束时间为：2018-12-26~2019-01-25。也正是因为这点，使用sql分组的方式就更加难以实现。所以我选用了第一个解决方案，就是在业务里处理这些时间。遂萌生了写这个工具类的想法。因为我们的业务需求比较特殊，所以下边贴上的代码还是按照自然月来处理的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272import java.text.SimpleDateFormat;import java.util.*;/** * 传开始和结束日期 按日、周、月、季、年分割成一些时间区间 * &lt;p&gt; */public class DateSeparateUtil &#123; /** * 按日分隔 * * @param startTime * @param endTime * @param format * @param timeForQuery 分隔好的时间区间 一个startTime和endTime为一组 * @param timeForShow 显示在横轴的时间区间 */ public static void separateByDay(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow) &#123; if (timeForQuery == null) &#123; timeForQuery = new ArrayList&lt;&gt;(); &#125; if (timeForShow == null) &#123; timeForShow = new ArrayList&lt;&gt;(); &#125; Calendar start = Calendar.getInstance(); start.setTime(startTime); Calendar end = Calendar.getInstance(); end.setTime(endTime); while (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); String startStr = format.format(new Date(start.getTimeInMillis())); map.put(\"startTime\", startStr + \" 00:00:00\"); // 按天算的话 开始和结束就是同一天 map.put(\"endTime\", startStr + \" 23:59:59\"); timeForQuery.add(map); timeForShow.add(startStr.substring(5, 10)); start.add(Calendar.DAY_OF_YEAR, 1); &#125; &#125; /** * 按星期分隔 * * @param startTime * @param endTime * @param format * @param timeForQuery * @param timeForShow */ public static void separateByWeek(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow) &#123; if (timeForQuery == null) &#123; timeForQuery = new ArrayList&lt;&gt;(); &#125; if (timeForShow == null) &#123; timeForShow = new ArrayList&lt;&gt;(); &#125; Calendar start = Calendar.getInstance(); start.setFirstDayOfWeek(Calendar.MONDAY); start.setTime(startTime); Calendar end = Calendar.getInstance(); end.setTime(endTime); while (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); String startStr = format.format(new Date(start.getTimeInMillis())); map.put(\"startTime\", startStr + \" 00:00:00\"); start.add(Calendar.DAY_OF_WEEK, /*start.getActualMaximum(Calendar.DAY_OF_WEEK)*/8 - start.get(Calendar.DAY_OF_WEEK)); if (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123; // 结束日期不能超过传来的最后日期 start.setTimeInMillis(end.getTimeInMillis()); &#125; String weekEnd = format.format(new Date(start.getTimeInMillis())); map.put(\"endTime\", weekEnd + \" 23:59:59\"); timeForQuery.add(map); timeForShow.add(startStr.substring(5, 10) + \"/\" + weekEnd.substring(5, 10)); // 加一天到下一周 start.add(Calendar.DAY_OF_WEEK, 1); &#125; &#125; /** * 按月分割 * * @param startTime * @param endTime * @param format * @param timeForQuery * @param timeForShow */ public static void separateByMonth(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow) &#123; if (timeForQuery == null) &#123; timeForQuery = new ArrayList&lt;&gt;(); &#125; if (timeForShow == null) &#123; timeForShow = new ArrayList&lt;&gt;(); &#125; Calendar start = Calendar.getInstance(); start.setTime(startTime); Calendar end = Calendar.getInstance(); end.setTime(endTime); while (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); String startStr = format.format(new Date(start.getTimeInMillis())); map.put(\"startTime\", startStr + \" 00:00:00\"); // region 按照自然月方式处理 start.set(Calendar.DAY_OF_MONTH, start.getActualMaximum(Calendar.DAY_OF_MONTH)); // endregion if (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123; start.setTimeInMillis(end.getTimeInMillis());// 不能超过end时期 &#125; Date monthEnd = new Date(start.getTimeInMillis()); map.put(\"endTime\", format.format(monthEnd) + \" 23:59:59\"); timeForQuery.add(map); timeForShow.add(format.format(monthEnd).substring(2, 7)); start.add(Calendar.DAY_OF_MONTH, 1); // 跳到下一天 &#125; &#125; /** * 按季度拆分 * * @param startTime * @param endTime * @param format * @param timeForQuery * @param timeForShow */ public static void separateByQuarter(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow) &#123; if (timeForQuery == null) &#123; timeForQuery = new ArrayList&lt;&gt;(); &#125; if (timeForShow == null) &#123; timeForShow = new ArrayList&lt;&gt;(); &#125; Calendar start = Calendar.getInstance(); start.setTime(startTime); Calendar end = Calendar.getInstance(); end.setTime(endTime); List&lt;Integer&gt; quarter1 = Arrays.asList(0, 1, 2); List&lt;Integer&gt; quarter2 = Arrays.asList(3, 4, 5); List&lt;Integer&gt; quarter3 = Arrays.asList(6, 7, 8); List&lt;Integer&gt; quarter4 = Arrays.asList(9, 10, 11); while (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123; int curMonth = start.get(Calendar.MONTH); // 0-11 // 处理第一季度的月份 if (quarter1.contains(curMonth)) &#123; handleQuarterOnce(quarter1, 1, timeForQuery, timeForShow, format, start, end); &#125; // 处理第二季度的月份 if (quarter2.contains(curMonth)) &#123; handleQuarterOnce(quarter2, 2, timeForQuery, timeForShow, format, start, end); &#125; // 处理第三季度的月份 if (quarter3.contains(curMonth)) &#123; handleQuarterOnce(quarter3, 3, timeForQuery, timeForShow, format, start, end); &#125; // 处理第四季度的月份 if (quarter4.contains(curMonth)) &#123; handleQuarterOnce(quarter4, 4, timeForQuery, timeForShow, format, start, end); &#125; &#125; &#125; /** * 按年分隔 * * @param startTime * @param endTime * @param format * @param timeForQuery * @param timeForShow */ public static void separateByYear(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow) &#123; if (timeForQuery == null) &#123; timeForQuery = new ArrayList&lt;&gt;(); &#125; if (timeForShow == null) &#123; timeForShow = new ArrayList&lt;&gt;(); &#125; Calendar start = Calendar.getInstance(); start.setTime(startTime); Calendar end = Calendar.getInstance(); end.setTime(endTime); while (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); String startStr = format.format(new Date(start.getTimeInMillis())); map.put(\"startTime\", startStr + \" 00:00:00\"); // region按自然月处理 start.set(Calendar.DAY_OF_YEAR, start.getActualMaximum(Calendar.DAY_OF_YEAR)); // endregion if (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123; start.setTimeInMillis(end.getTimeInMillis()); &#125; String yearEnd = format.format(new Date(start.getTimeInMillis())); map.put(\"endTime\", yearEnd + \" 23:59:59\"); timeForQuery.add(map); timeForShow.add(yearEnd.substring(0, 4)); start.add(Calendar.DAY_OF_YEAR, 1);// 跳下一天 &#125; &#125; /**************************************************私有方法*********************************************************/ /** * 近供分割季度的方法使用 * * @param monthInQuarter List&lt;Integer&gt; quarter1 = Arrays.asList(0, 1, 2); * @param quarter 1\\2\\3\\4 * @param timeForQuery * @param timeForShow * @param format * @param start * @param end */ private static void handleQuarterOnce(List&lt;Integer&gt; monthInQuarter, int quarter, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow, SimpleDateFormat format, Calendar start, Calendar end) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); String startStr = format.format(start.getTimeInMillis()); map.put(\"startTime\", startStr + \" 00:00:00\"); // 设置为季度最后一天 // region 自然月的方式处理 start.set(Calendar.MONTH, monthInQuarter.get(2)); start.set(Calendar.DAY_OF_MONTH, start.getActualMaximum(Calendar.DAY_OF_MONTH)); // endregion // 防止超出时间范围 if (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123; start.setTimeInMillis(end.getTimeInMillis()); &#125; String quarterEnd = format.format(new Date(start.getTimeInMillis())); map.put(\"endTime\", quarterEnd + \" 23:59:59\"); timeForQuery.add(map); timeForShow.add(quarterEnd.substring(0, 4) + \"年\" + quarter + \"季度\"); start.add(Calendar.DAY_OF_MONTH, 1);// +1天 &#125; /*****************************************************测试*********************************************************/ public static void main(String[] args) throws Exception &#123; Calendar instance = Calendar.getInstance(); instance.add(Calendar.DAY_OF_YEAR, 300); SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");// Date now = new Date();// Date end = new Date(instance.getTimeInMillis()); Date now = format.parse(\"2017-09-26\"); Date end = format.parse(\"2019-04-20\");// List&lt;Map&lt;String, String&gt;&gt; maps = separateByDay(new Date(), new Date(instance.getTimeInMillis()), format);// System.out.println(maps); ArrayList&lt;Map&lt;String, String&gt;&gt; timeForQuery = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; timeForShow = new ArrayList&lt;&gt;();// separateByWeek(now, end, format, timeForQuery, timeForShow);// separateByMonth(now, end, format, timeForQuery, timeForShow);// assert (!ObjectUtils.hasLength(timeForQuery)):\"OJBK\";// separateByQuarter(now, end, format, timeForQuery, timeForShow); separateByYear(now, end, format, timeForQuery, timeForShow); System.out.println(timeForQuery); System.out.println(timeForShow); &#125;&#125;","categories":[],"tags":[]}]}