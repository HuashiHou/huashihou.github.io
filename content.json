{"meta":{"title":"Wayne's blog","subtitle":"一个有情调的程序员","description":null,"author":"侯骅十","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-06-05T08:43:39.000Z","updated":"2019-06-05T08:43:56.155Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-05T08:42:46.000Z","updated":"2019-06-05T08:43:21.820Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于二分查找（折半查找）的即记录","slug":"关于二分查找（折半查找）的即记录","date":"2019-06-05T07:36:18.000Z","updated":"2019-06-05T07:47:40.675Z","comments":true,"path":"posts/1/","link":"","permalink":"http://yoursite.com/posts/1/","excerpt":"","text":"关于二分查找（折半查找）的即记录之前其实也学习过二分查找的理念，但是一直有一个模糊的地方就是中间元素的选取。 二分查找需要的数组需要是有序的。 二分查找的步骤 确定数组的中间元素 将待查找元素与中间元素比较 如果大于中间元素，则到右边的数组查找，反之同理 如果中间元素等于待查找元素，那么查找成功。 之前一直迷惑的一点就是第一步当中的中间元素的选取，因为数组会有两种情况，一种是元素的个数为偶数，另一种是数组元素个数为奇数。 今天到网上查找相关资料，才补上了这个基础的知识： 中间元素的选取可以使用如下公式：mid = left + (right - left)/2; 这样不论当数组元素个数为偶数或者奇数的时候都可以正确选取到中间元素。 二分查找的思想其实二分查找是利用的算法设计思想中的 分治法，一步一步缩小查找范围，最终得到问题的解。 分治法：将一个复杂的问题分解为多个相同或相似的子问题，再对子问题进行求解，进而得到问题的解。 二分法的求解过程可以用二叉树来描述，对于一个有序的数组，根结点为最开始选取的中间元素，根结点的左右两个孩子分别为左数组的中间节点及右数组的中间节点，孩子的孩子同理； 所以通过查找树（判定树）可以看出查找的元素要经过几次比较以及跟哪些元素进行了比较。 二分查找的时间复杂度O(log2n)","categories":[],"tags":[]},{"title":"如何给自己的网站添加小绿锁","slug":"如何给自己的网站添加小绿锁","date":"2019-06-05T07:36:18.000Z","updated":"2019-06-05T07:47:46.773Z","comments":true,"path":"posts/2/","link":"","permalink":"http://yoursite.com/posts/2/","excerpt":"","text":"如何给自己的网站添加小绿锁首先 要值得庆祝的是我的网站通过备案了 之前我的博客是用的hexo博客，项目托管在github.io上，在本地使用Markdown写好文章 编译发布到git仓库就可以了。因此也无需备案。不过发现，github的访问速度不稳定，时快时慢就比较坑爹 前一阵刚好赶上了阿里云的双11活动，直接298买了个最低配的3年，寻思买来放放博客，自己的小项目什么的都挺好。刚好朋友最近推荐了一个java的开源博客项目 就是现在用的tale，而且hexo看久了 也腻了 而hexo且没有后台，要手写markdown然后手动编译再git push 挺麻烦的。所以我就在阿里云上搭了这个tale。功能比较简洁明了，用的是内置sqlite，总共没有几张表。不依赖容器。如何安装tale大家直接点连接进去看就可以了，很简单 傻瓜式操作。 接下来讲讲如何给你的网站添加小绿锁 以下提到两个证书供应商都提供免费的ssl DV证书，letsencrypt三个月需要续期，可以自动续期，阿里云免费一年。 使用letsencrypt给站点添加ssl比较热门和方便的一个方法就是使用letsencrypt的Certbot自动给你的站点添加证书。进入到certbot网站可以看到支持的服务器以及系统，本人推荐使用nginx，配置比较方便。大概过程就是连接到你的服务器，安装certbot，配置一下nginx就ok了。这里不多讲certbot的使用了，因为我用的是阿里云的证书。 阿里云ssl证书如果你的域名也是在阿里云购买的话，这个过程就会更加方便。 在阿里云购买的域名–》直接进入阿里云控制台 –域名 点击管理，里面有申请免费的ssl证书。 不是在阿里云购买的域名就要在阿里云搜索ssl进入根据提示申请一个免费的ssl证书，这里相较于 1 麻烦的就是要手动验证域名的所有权。可能要添加一条text类型的解析记录。 现在假定你已经申请好了证书，可以看到证书管理界面你的证书那里有个下载，点击他，下载完你会拿到一个压缩包，里面有量个主要的文件，一个是以crt结尾的证书文件，一个是以key结尾的私钥文件。 剩下的步骤 阿里云的官方文档已经讲的很清楚了，详见：Nginx/Tengine服务器安装SSL证书。 Tomcat的也有，详见：Tomcat服务器安装SSL证书 有一点要注意的是https使用的是443端口，http默认是80端口，所以要到阿里云的安全组添加开放你的443端口 后续配置做完上边的工作，你的网站应该就可以使用https://your.domain来访问了~ 但细心的小伙伴会发现一个问题，这里一定要手动加上https的头，为什么人家的网站都可以直接使用域名访问自动跳转到https呢，其实这里也是后台要配置一个转发，将http的请求全部全部转到https。下边是我完整的nginx配置文件 供大家参考。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name wasea.top www.wasea.top; root /usr/share/nginx/html; rewrite ^(.*)$ https://$host$1 permanent; # 重要的一个配置，可以自动转到https # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; proxy_pass http://localhost:9000; # 我的tale博客默认使用9000端口 &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;# start aliyun ssl configserver &#123;# listen 443; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name wasea.top www.wasea.top; ssl on; root html; index index.html index.htm; ssl_certificate cert/a.pem; ssl_certificate_key cert/a.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; add_header Content-Security-Policy upgrade-insecure-requests; proxy_pass http://localhost:9000; &#125;&#125;# end aliyun ssl config&#125; 还有一点值得说的是，我这里省略了linux下一些细节的操作命令，例如给防火墙开放端口、安装nginx 等等其他，这些每个系统都有细微的区别，大家根据自己的系统来操作就好了。","categories":[],"tags":[]},{"title":"深入理解MyBatis（一）","slug":"深入理解MyBatis（一）","date":"2019-06-05T07:36:18.000Z","updated":"2019-06-05T07:48:06.690Z","comments":true,"path":"posts/4/","link":"","permalink":"http://yoursite.com/posts/4/","excerpt":"","text":"深入理解MyBatis（一）MyBatis的基本运行过程 输入配置文件的文件流 使用SqlSessionFactoryBuilder根据配置文件创建SqlSessionFactory 通过SqlSessionFactory获取会话SqlSession 从SqlSession获取Executor Executor读取并执行sql语句 StatementHandler处理jdbc的statement交互 TypeHandler负责设置参数 使用jdbc与数据库进行交互 jdbc返回结果集-》TypeHandler-》ResultHandler-》StatementHandler-》Executor-》SqlSession 上述过程使用图片来描述会比较清晰。 MyBatis的缓存机制一级缓存Executor在Mybatis中扮演者非常重要的一个角色，除了用来控制执行sql返回结果之外，它还有一个重要的指责就是缓存的管理。 在一个SqlSession的会话中，如果使用了同样的sql以及同样的参数两次以上，那么在第二次查询的时候就会命中mybatis的一级缓存，不再次查库； 在这个session会话中，如果有进行增删改操作，那么mybatis就会刷新缓存避免脏读现象的发生； 一级缓存在Mybatis中是默认开启的。 二级缓存二级缓存在Mybatis中其实也是默认开启的，二级缓存对应的配置项为&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; ，但是如果想要使用二级缓存需要在对应的mapper文件中加上如下配置 12&lt;!-- 开启mapper的二级缓存， type:指定cache接口的实现类，mybatis默认使用PerpetualCache 要和ehcache整合，需要配置type为ehcache实现cache接口的类型 --&gt;&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt;&lt;/cache&gt; 如果不需要指定忽略type参数就可以了: &lt;cache/&gt;。 关于二级缓存的划分：既可以每个mapper使用自己的空间，也可以多个mapper共享一个空间（使用&lt;cache-ref namespace=&quot;xx&quot;/&gt;来配置）。 Mybatis对二级缓存的粒度控制很细，所以如果想要使用二级缓存，需要在指定的select标签中开启对该条语句进行缓存cacheEnabled=true。 实现原理Mybatis实现二级缓存使用了装饰器模式，使用CachingExecutor装饰了Executor；从上文我们可以知道Executor控制了一级缓存，所以我们可以发现在一二级缓存同时开启式，mybatis是会优先使用二级缓存的。 最后：关于实际应用中的缓存原则：尽量离客户端近；能用cdn的就cdn，能在nginx缓存的就在nginx缓存，接下来在控制层，业务层进行缓存，基本上在实际应用中不会使用到数据库级别的缓存。","categories":[],"tags":[]},{"title":"跨域资源共享CORS 详解","slug":"跨域资源共享CORS 详解","date":"2019-06-05T07:36:18.000Z","updated":"2019-06-05T07:48:18.440Z","comments":true,"path":"posts/5/","link":"","permalink":"http://yoursite.com/posts/5/","excerpt":"","text":"跨域资源共享CORS 详解http://www.ruanyifeng.com/blog/2016/04/cors.html","categories":[],"tags":[]},{"title":"关于token机制与JWT标准","slug":"关于token机制与JWT标准","date":"2019-06-05T07:36:18.000Z","updated":"2019-06-05T07:49:13.679Z","comments":true,"path":"posts/33574/","link":"","permalink":"http://yoursite.com/posts/33574/","excerpt":"","text":"关于token机制与JWT标准在传统的web单体项目中，我们的会话通常使用session和cookie两样来实现。 传统的cookie/session实现session是保存在服务器端的会话，使用cookie在客户端保存一个session id，每次发送请求的时候带上这个cookie服务端就可以很容易的了解当前用户是否与服务端建立了会话，以及会话是否过期等等。在单体项目中的这种实现机制相对来说是比较方便的。 使用这种机制存在的问题： 当我们的项目变得越来越大，用户数量越来越多之后，每新建一个会话服务器就要多消耗空间来存储空间，这将使服务器内存的开销不断增加； 跨域问题，很多项目使用前后端分离开发，而且前后端也部署在不同的域，这将导致一系列跨域问题的发生； 可拓展性，只在服务器内存中存储session限制了可拓展性能； 针对以上痛点，token机制的出现很好的解决了问题。 token机制使用token机制时，当用户请求时，会检查用户是否有携带token信息，或者token是否过期；未登录的话叫用户进行登录，然后服务端生成一串token返回给浏览器，可以存储在cookie或者localStorage里面。以后用户每一次发送的请求都会带上这个token。 token的组成一般是一些基础的信息，加上一个签名。这样服务器就无需存储session，每当收到一个新的请求，对token的签名进行验证，验证成功就可以进行下一步的操作。而且通常token可以存储在数据库中。 JWT（Json Web Token）广义上的jwt其实是token机制的一个实现标准，狭义上的jwt即是我们每次请求携带的token串。 jwt串由3部分组成，下面是一个例子： 123eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 第一部分为header为json格式 1234&#123; \"alg\": \"HS256\", 加密算法类型 \"typ\": \"JWT\" token类型&#125; 第二部分为payload 同样为json： 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, 保留claim subject代表这个jwt的主体 &quot;name&quot;: &quot;John Doe&quot;, 自定义的claim &quot;iat&quot;: 1516239022 保留claim 时间戳 代表jwt的签发时间&#125; 第三部分就是用header中指定的算法结合payload的内容制造出的签名。 jwt串只是使用base64编码，并没有进行加密，所以任何人获取到jwt串都可以拿到其中传输的内容。 当服务端获取到这一tokne之后，会有如下事件流： 使用base64将jwt串进行还原 使用header中的算法对签名部分进行还原 对比直接从jwt中解析出的payload部分和使用算法还原的payload 如果不一致 验证失败 一致则验证成功 总结token机制是针对无状态的http比较好的一个会话管理机制；对前后端分离项目、用户量大的项目都更加友好；对移动端的支持也更好。 参考资料： https://jwt.io/ https://www.cnblogs.com/moyand/p/9047978.html https://www.cnblogs.com/lyzg/p/6028341.html","categories":[],"tags":[]},{"title":"小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间","slug":"小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间","date":"2019-02-03T04:33:18.000Z","updated":"2019-06-05T07:48:44.857Z","comments":true,"path":"posts/3/","link":"","permalink":"http://yoursite.com/posts/3/","excerpt":"","text":"小工具：将传入的日期区间按日、周、月、季、年分隔成多个时间区间最近在做公司项目的时候，有一个需求是需要传入一个开始时间和一个结束时间。但是要按照统计的方式分别以日、周、月、季、年的方式来分组进行统计。这个问题其实有两个解决方案，一个是利用sql处理日期的字段格式化进行分组；另一种就是写一个通用一点的SQL，然后在service里处理这些日期，遍历调用这个接口。由于我们的需求对时间的要求比较复杂，并不可以按照自然月的方式进行统计，而是上个月26到本月25日为一个周期。比如统计2019年1月，实际上的开始和结束时间为：2018-12-26~2019-01-25。也正是因为这点，使用sql分组的方式就更加难以实现。所以我选用了第一个解决方案，就是在业务里处理这些时间。遂萌生了写这个工具类的想法。因为我们的业务需求比较特殊，所以下边贴上的代码还是按照自然月来处理的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272import java.text.SimpleDateFormat;import java.util.*;/** * 传开始和结束日期 按日、周、月、季、年分割成一些时间区间 * &lt;p&gt; */public class DateSeparateUtil &#123; /** * 按日分隔 * * @param startTime * @param endTime * @param format * @param timeForQuery 分隔好的时间区间 一个startTime和endTime为一组 * @param timeForShow 显示在横轴的时间区间 */ public static void separateByDay(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow) &#123; if (timeForQuery == null) &#123; timeForQuery = new ArrayList&lt;&gt;(); &#125; if (timeForShow == null) &#123; timeForShow = new ArrayList&lt;&gt;(); &#125; Calendar start = Calendar.getInstance(); start.setTime(startTime); Calendar end = Calendar.getInstance(); end.setTime(endTime); while (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); String startStr = format.format(new Date(start.getTimeInMillis())); map.put(\"startTime\", startStr + \" 00:00:00\"); // 按天算的话 开始和结束就是同一天 map.put(\"endTime\", startStr + \" 23:59:59\"); timeForQuery.add(map); timeForShow.add(startStr.substring(5, 10)); start.add(Calendar.DAY_OF_YEAR, 1); &#125; &#125; /** * 按星期分隔 * * @param startTime * @param endTime * @param format * @param timeForQuery * @param timeForShow */ public static void separateByWeek(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow) &#123; if (timeForQuery == null) &#123; timeForQuery = new ArrayList&lt;&gt;(); &#125; if (timeForShow == null) &#123; timeForShow = new ArrayList&lt;&gt;(); &#125; Calendar start = Calendar.getInstance(); start.setFirstDayOfWeek(Calendar.MONDAY); start.setTime(startTime); Calendar end = Calendar.getInstance(); end.setTime(endTime); while (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); String startStr = format.format(new Date(start.getTimeInMillis())); map.put(\"startTime\", startStr + \" 00:00:00\"); start.add(Calendar.DAY_OF_WEEK, /*start.getActualMaximum(Calendar.DAY_OF_WEEK)*/8 - start.get(Calendar.DAY_OF_WEEK)); if (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123; // 结束日期不能超过传来的最后日期 start.setTimeInMillis(end.getTimeInMillis()); &#125; String weekEnd = format.format(new Date(start.getTimeInMillis())); map.put(\"endTime\", weekEnd + \" 23:59:59\"); timeForQuery.add(map); timeForShow.add(startStr.substring(5, 10) + \"/\" + weekEnd.substring(5, 10)); // 加一天到下一周 start.add(Calendar.DAY_OF_WEEK, 1); &#125; &#125; /** * 按月分割 * * @param startTime * @param endTime * @param format * @param timeForQuery * @param timeForShow */ public static void separateByMonth(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow) &#123; if (timeForQuery == null) &#123; timeForQuery = new ArrayList&lt;&gt;(); &#125; if (timeForShow == null) &#123; timeForShow = new ArrayList&lt;&gt;(); &#125; Calendar start = Calendar.getInstance(); start.setTime(startTime); Calendar end = Calendar.getInstance(); end.setTime(endTime); while (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); String startStr = format.format(new Date(start.getTimeInMillis())); map.put(\"startTime\", startStr + \" 00:00:00\"); // region 按照自然月方式处理 start.set(Calendar.DAY_OF_MONTH, start.getActualMaximum(Calendar.DAY_OF_MONTH)); // endregion if (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123; start.setTimeInMillis(end.getTimeInMillis());// 不能超过end时期 &#125; Date monthEnd = new Date(start.getTimeInMillis()); map.put(\"endTime\", format.format(monthEnd) + \" 23:59:59\"); timeForQuery.add(map); timeForShow.add(format.format(monthEnd).substring(2, 7)); start.add(Calendar.DAY_OF_MONTH, 1); // 跳到下一天 &#125; &#125; /** * 按季度拆分 * * @param startTime * @param endTime * @param format * @param timeForQuery * @param timeForShow */ public static void separateByQuarter(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow) &#123; if (timeForQuery == null) &#123; timeForQuery = new ArrayList&lt;&gt;(); &#125; if (timeForShow == null) &#123; timeForShow = new ArrayList&lt;&gt;(); &#125; Calendar start = Calendar.getInstance(); start.setTime(startTime); Calendar end = Calendar.getInstance(); end.setTime(endTime); List&lt;Integer&gt; quarter1 = Arrays.asList(0, 1, 2); List&lt;Integer&gt; quarter2 = Arrays.asList(3, 4, 5); List&lt;Integer&gt; quarter3 = Arrays.asList(6, 7, 8); List&lt;Integer&gt; quarter4 = Arrays.asList(9, 10, 11); while (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123; int curMonth = start.get(Calendar.MONTH); // 0-11 // 处理第一季度的月份 if (quarter1.contains(curMonth)) &#123; handleQuarterOnce(quarter1, 1, timeForQuery, timeForShow, format, start, end); &#125; // 处理第二季度的月份 if (quarter2.contains(curMonth)) &#123; handleQuarterOnce(quarter2, 2, timeForQuery, timeForShow, format, start, end); &#125; // 处理第三季度的月份 if (quarter3.contains(curMonth)) &#123; handleQuarterOnce(quarter3, 3, timeForQuery, timeForShow, format, start, end); &#125; // 处理第四季度的月份 if (quarter4.contains(curMonth)) &#123; handleQuarterOnce(quarter4, 4, timeForQuery, timeForShow, format, start, end); &#125; &#125; &#125; /** * 按年分隔 * * @param startTime * @param endTime * @param format * @param timeForQuery * @param timeForShow */ public static void separateByYear(Date startTime, Date endTime, SimpleDateFormat format, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow) &#123; if (timeForQuery == null) &#123; timeForQuery = new ArrayList&lt;&gt;(); &#125; if (timeForShow == null) &#123; timeForShow = new ArrayList&lt;&gt;(); &#125; Calendar start = Calendar.getInstance(); start.setTime(startTime); Calendar end = Calendar.getInstance(); end.setTime(endTime); while (start.getTimeInMillis() &lt; end.getTimeInMillis()) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); String startStr = format.format(new Date(start.getTimeInMillis())); map.put(\"startTime\", startStr + \" 00:00:00\"); // region按自然月处理 start.set(Calendar.DAY_OF_YEAR, start.getActualMaximum(Calendar.DAY_OF_YEAR)); // endregion if (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123; start.setTimeInMillis(end.getTimeInMillis()); &#125; String yearEnd = format.format(new Date(start.getTimeInMillis())); map.put(\"endTime\", yearEnd + \" 23:59:59\"); timeForQuery.add(map); timeForShow.add(yearEnd.substring(0, 4)); start.add(Calendar.DAY_OF_YEAR, 1);// 跳下一天 &#125; &#125; /**************************************************私有方法*********************************************************/ /** * 近供分割季度的方法使用 * * @param monthInQuarter List&lt;Integer&gt; quarter1 = Arrays.asList(0, 1, 2); * @param quarter 1\\2\\3\\4 * @param timeForQuery * @param timeForShow * @param format * @param start * @param end */ private static void handleQuarterOnce(List&lt;Integer&gt; monthInQuarter, int quarter, List&lt;Map&lt;String, String&gt;&gt; timeForQuery, List&lt;String&gt; timeForShow, SimpleDateFormat format, Calendar start, Calendar end) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); String startStr = format.format(start.getTimeInMillis()); map.put(\"startTime\", startStr + \" 00:00:00\"); // 设置为季度最后一天 // region 自然月的方式处理 start.set(Calendar.MONTH, monthInQuarter.get(2)); start.set(Calendar.DAY_OF_MONTH, start.getActualMaximum(Calendar.DAY_OF_MONTH)); // endregion // 防止超出时间范围 if (start.getTimeInMillis() &gt; end.getTimeInMillis()) &#123; start.setTimeInMillis(end.getTimeInMillis()); &#125; String quarterEnd = format.format(new Date(start.getTimeInMillis())); map.put(\"endTime\", quarterEnd + \" 23:59:59\"); timeForQuery.add(map); timeForShow.add(quarterEnd.substring(0, 4) + \"年\" + quarter + \"季度\"); start.add(Calendar.DAY_OF_MONTH, 1);// +1天 &#125; /*****************************************************测试*********************************************************/ public static void main(String[] args) throws Exception &#123; Calendar instance = Calendar.getInstance(); instance.add(Calendar.DAY_OF_YEAR, 300); SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");// Date now = new Date();// Date end = new Date(instance.getTimeInMillis()); Date now = format.parse(\"2017-09-26\"); Date end = format.parse(\"2019-04-20\");// List&lt;Map&lt;String, String&gt;&gt; maps = separateByDay(new Date(), new Date(instance.getTimeInMillis()), format);// System.out.println(maps); ArrayList&lt;Map&lt;String, String&gt;&gt; timeForQuery = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; timeForShow = new ArrayList&lt;&gt;();// separateByWeek(now, end, format, timeForQuery, timeForShow);// separateByMonth(now, end, format, timeForQuery, timeForShow);// assert (!ObjectUtils.hasLength(timeForQuery)):\"OJBK\";// separateByQuarter(now, end, format, timeForQuery, timeForShow); separateByYear(now, end, format, timeForQuery, timeForShow); System.out.println(timeForQuery); System.out.println(timeForShow); &#125;&#125;","categories":[],"tags":[]}]}